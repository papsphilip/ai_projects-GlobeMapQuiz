<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Interactive 3D globe geography quiz game. Test your knowledge of countries, flags, and locations with multiple game modes.">
    <meta name="keywords" content="geography quiz, globe game, country quiz, flag quiz, educational game, 3D globe">
    <meta name="author" content="Globe Map Quiz">
    <meta name="theme-color" content="#0f172a">
    <!-- Open Graph / Social Media -->
    <meta property="og:title" content="Geography Quiz - Ultimate Expedition">
    <meta property="og:description" content="Interactive 3D globe geography quiz game with multiple modes">
    <meta property="og:type" content="website">
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåç</text></svg>">
    <title>Geography Quiz - Ultimate Expedition</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Earcut -->
    <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;700;800;900&family=Rubik:wght@400;500;700&family=Fira+Code:wght@400;500;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* ============================================
           GLOBE MAP QUIZ - STYLESHEET
           ============================================
           Table of Contents:
           1. CSS Variables & Themes
           2. Base Styles
           3. Layout & Containers
           4. Glass Panel Components
           5. Navigation & Panels
           6. Country Index & Tags
           7. Crosshair Overlay
           8. Form Elements
           9. Splash Screen
           10. Quiz UI Components
           11. Radial Menu
           12. Feedback & Animations
           13. Utilities
           14. Accessibility
           ============================================ */

        /* ============================================
           1. CSS VARIABLES & THEMES
           ============================================ */
        :root {
            /* Core Colors */
            --bg-color: #0f172a;
            --panel-bg: rgba(15, 23, 42, 0.85);
            --accent-color: #38bdf8;
            --text-color: #f1f5f9;
            --border-color: rgba(56, 189, 248, 0.3);

            /* Typography */
            --font-main: 'Outfit', sans-serif;
            --font-head: 'Rubik', sans-serif;
            --font-mono: 'Fira Code', monospace;
            --sidebar-font-size: 0.875rem;

            /* Sizing */
            --flag-size: 1.5rem;
            --panel-radius: 1rem;
            --panel-border-width: 1px;
            --panel-blur: 16px;

            /* Crosshair */
            --crosshair-color: var(--accent-color);
            --crosshair-font-size: 10px;

            /* Transitions */
            --transition-fast: 0.15s;
            --transition-normal: 0.3s;
            --transition-slow: 0.5s;
        }

        /* --- Theme Definitions --- */
        body.theme-cyber {
            --bg-color: #0f172a;
            --panel-bg: rgba(15, 23, 42, 0.9);
            --accent-color: #38bdf8;
            --text-color: #f1f5f9;
            --border-color: rgba(56, 189, 248, 0.3);
            --font-main: 'Outfit', sans-serif;
            --font-head: 'Rubik', sans-serif;
            --panel-radius: 1.5rem;
        }

        body.theme-royal {
            --bg-color: #1a0b2e;
            --panel-bg: rgba(26, 11, 46, 0.85);
            --accent-color: #fbbf24;
            --text-color: #fef3c7;
            --border-color: rgba(251, 191, 36, 0.4);
            --font-main: 'Outfit', sans-serif;
            --font-head: 'Rubik', sans-serif;
            --panel-radius: 1.5rem;
        }

        body.theme-terminal {
            --bg-color: #000000;
            --panel-bg: #111111;
            --accent-color: #00ff00;
            --text-color: #00ff00;
            --border-color: #00ff00;
            --font-main: 'Fira Code', monospace;
            --font-head: 'Fira Code', monospace;
            --panel-radius: 0;
        }

        body.theme-paper {
            --bg-color: #f3f4f6;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --accent-color: #1f2937;
            --text-color: #111827;
            --border-color: #9ca3af;
            --font-main: 'Playfair Display', serif;
            --font-head: 'Playfair Display', serif;
            --panel-radius: 1.5rem;
        }

        body.theme-midnight {
            --bg-color: #000000;
            --panel-bg: rgba(20, 20, 20, 0.8);
            --accent-color: #6366f1;
            --text-color: #e0e7ff;
            --border-color: rgba(99, 102, 241, 0.4);
            --font-main: 'Outfit', sans-serif;
            --font-head: 'Rubik', sans-serif;
            --panel-radius: 1.5rem;
        }

        body.theme-navy {
            --bg-color: #0a1628;
            --panel-bg: rgba(10, 22, 40, 0.9);
            --accent-color: #f59e0b;
            --text-color: #fef3c7;
            --border-color: rgba(245, 158, 11, 0.3);
            --font-main: 'Outfit', sans-serif;
            --font-head: 'Rubik', sans-serif;
            --panel-radius: 1rem;
        }

        /* --- Theme-Specific Effects --- */
        /* Terminal Theme: CRT scanlines */
        body.theme-terminal::before {
            content: '';
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 0, 0.03) 0px,
                rgba(0, 255, 0, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 9999;
        }
        body.theme-terminal .glass-panel {
            border-radius: 0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        /* Cyber Theme: Neon glow on accent elements */
        body.theme-cyber .mode-btn.selected,
        body.theme-cyber .diff-btn.selected,
        body.theme-cyber .param-btn.selected {
            box-shadow: 0 0 15px var(--accent-color);
        }
        body.theme-cyber .glass-panel {
            box-shadow: 0 8px 32px rgba(56, 189, 248, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        /* Royal Theme: Gold gradients */
        body.theme-royal .glass-panel {
            border-image: linear-gradient(135deg, rgba(251, 191, 36, 0.6), transparent, rgba(251, 191, 36, 0.6)) 1;
        }
        body.theme-royal .mode-btn.selected,
        body.theme-royal .diff-btn.selected {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
        }

        /* Paper Theme: Subtle texture */
        body.theme-paper .glass-panel {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            border: 1px solid #d1d5db;
        }

        /* Midnight Theme: Purple glow */
        body.theme-midnight .glass-panel {
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.2);
        }
        body.theme-midnight .mode-btn.selected,
        body.theme-midnight .diff-btn.selected {
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.5);
        }

        /* ============================================
           2. BASE STYLES
           ============================================ */
        body { 
            margin: 0; overflow: hidden; background-color: var(--bg-color); font-family: var(--font-main); color: var(--text-color); transition: background-color 0.5s; 
        }
        
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top: 0; left: 0; z-index: 0; }

        /* ============================================
           3. LAYOUT & CONTAINERS
           ============================================ */

        /* ============================================
           4. GLASS PANEL COMPONENTS
           ============================================ */
        .glass-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: var(--panel-border-width) solid var(--border-color);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .naked-btn {
            background: transparent; border: none; color: var(--accent-color);
            width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; cursor: pointer; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }
        .naked-btn:hover { transform: scale(1.15); color: white; filter: drop-shadow(0 0 8px var(--accent-color)); }

        /* Drag handle used to resize the country index panel width. */
        .drag-handle {
            position: absolute;
            top: 0;
            right: -3px;
            width: 6px;
            height: 100%;
            cursor: ew-resize;
            z-index: 100;
            /* subtle visual indicator */
            background: linear-gradient(to right, transparent, var(--border-color), transparent);
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .drag-handle:hover {
            opacity: 0.9;
        }

        .naked-panel {
            background: transparent; border: none; box-shadow: none; backdrop-filter: none;
            text-shadow: 0 2px 8px rgba(0,0,0,0.9), 0 0 15px rgba(0,0,0,0.5);
        }

        h1, h2, h3, .font-head { font-family: var(--font-head); }

        /* Scrollbar Styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); margin: 10px 0; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent-color); }

        /* ============================================
           5. NAVIGATION & PANELS
           ============================================ */
        .side-panel { transform: translateX(-120%); transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .side-panel.open { transform: translateX(0); }
        .settings-panel { transform: translateX(120%); transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-panel.open { transform: translateX(0); }

        /* ============================================
           6. COUNTRY INDEX & TAGS
           ============================================ */
        .subregion-header {
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.15em; color: var(--accent-color);
            padding: 1.5rem 0.5rem 0.5rem; border-bottom: 1px solid var(--border-color); margin-bottom: 0.5rem;
            position: sticky; top: 0; background: var(--panel-bg); z-index: 10; font-weight: 800;
        }


        /* Update country grid to be flexible tag layout. Each region will now
           contain a flexible row of tag elements that wrap based on
           available space. */
        .country-grid { display: flex; flex-wrap: wrap; gap: 0.4rem; padding-bottom: 1rem; }

        .country-item {
            padding: 0.25rem 0.5rem; border-radius: 1rem; cursor: pointer;
            display: flex; align-items: center; gap: 0.5rem;
            font-size: var(--sidebar-font-size);
            background: rgba(255,255,255,0.05);
            border: 1px solid transparent;
            white-space: nowrap;
            transition: all 0.2s;
        }
        .country-item:hover {
            background: rgba(255,255,255,0.12);
            border-color: var(--border-color);
            transform: translateY(-2px);
        }
        /* Selected country in navigation mode is highlighted. */
        .country-item.selected {
            background: var(--accent-color);
            color: var(--bg-color);
            border-color: var(--accent-color);
        }
        .country-item.found-correct { background: rgba(34, 197, 94, 0.2); border: 1px solid #22c55e; color: #86efac; }
        .country-item.found-skipped { background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444; color: #fca5a5; }
        .country-item img { width: var(--flag-size); height: auto; flex-shrink: 0; border-radius: 2px; }
        .country-item span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        /* 2D flag tags for indicating selected countries and small islands on the screen. */
        .flag-tag {
            position: absolute;
            padding: 2px 4px;
            background: var(--panel-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.65rem; /* slightly larger for readability */
            white-space: nowrap;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transform: translate(-50%, -50%);
            z-index: 50;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .flag-tag img {
            width: 1rem;
            height: 0.65rem;
            object-fit: cover;
            border-radius: 2px;
            flex-shrink: 0;
        }
        .flag-tag.far {
            width: 0.6rem;
            height: 0.6rem;
            padding: 0;
            border-radius: 50%;
            background: var(--accent-color);
            border: none;
            overflow: hidden;
        }
        .flag-tag.far img, .flag-tag.far span { display: none; }

        /* Container that holds all 2D flag tags */
        #tag-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 45;
        }

        /* Increase score and lives font sizes for better readability */
        #score-display {
            font-size: 2.5rem !important;
        }
        #lives-display {
            font-size: 2.5rem !important;
        }

        /* HUD Bar Sizing */
        #hud-bar {
            padding-top: 0.6rem !important;
            padding-bottom: 0.6rem !important;
            min-height: 80px;
        }

        /* ============================================
           7. CROSSHAIR OVERLAY
           ============================================ */
        #crosshair {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 900;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        #crosshair .v-line, #crosshair .h-line {
            position: absolute;
            background: var(--crosshair-color, var(--accent-color));
            opacity: 0.8;
        }
        #crosshair .v-line {
            width: 1px;
            height: 100%;
        }
        #crosshair .h-line {
            height: 1px;
            width: 100%;
        }
        /* Central shape for the crosshair. Shape will be circle or square based on user setting. */
        #crosshair-center {
            position: absolute;
            width: 14px;
            height: 14px;
            background: var(--panel-bg);
            border: 1px solid var(--crosshair-color, var(--accent-color));
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        /* Label showing latitude and longitude near the crosshair. */
        #crosshair-coords {
            position: absolute;
            font-size: var(--crosshair-font-size, 10px);
            color: var(--crosshair-color, var(--accent-color));
            background: rgba(0,0,0,0.5);
            padding: 2px 4px;
            border-radius: 4px;
            pointer-events: none;
            transform: translate(-50%, -120%);
            white-space: nowrap;
            display: none;
        }

        /* Error toggle button styles: coloured circles with text inside */
        /* Error toggle inherits the common HUD control button size and style.  Width and height
           are kept consistent with other control buttons (36px) and the indicator text is
           centered inside.  The error-on/off classes update the background colour. */
        #error-toggle-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 8px;
            font-weight: bold;
            text-transform: uppercase;
        }
        #error-toggle-btn.error-on {
            background: #16a34a;
            color: #fff;
        }
        #error-toggle-btn.error-off {
            background: #dc2626;
            color: #fff;
        }

        /* Mode display panel sliding below the HUD bar */
        #mode-panel {
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translate(-50%, 0);
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            padding: 0.75rem 1.5rem;
            border-radius: 1rem;
            font-size: 1rem;
            line-height: 1.2;
            opacity: 0;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            box-shadow: 0 6px 24px rgba(0,0,0,0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        #mode-panel svg {
            width: 32px;
            height: 32px;
        }
        #mode-panel.show {
            opacity: 1;
        }

        /* ============================================
           8. FORM ELEMENTS
           ============================================ */
        input[type="text"], input[type="number"] {
            background: rgba(0,0,0,0.3); border: 1px solid var(--border-color); color: var(--text-color); outline: none;
            padding: 0.75rem 1rem; border-radius: 0.75rem; transition: 0.3s; font-family: var(--font-main);
        }
        input[type="text"]:focus, input[type="number"]:focus {
            border-color: var(--accent-color); box-shadow: 0 0 20px -5px var(--accent-color); background: rgba(0,0,0,0.6);
        }
        
        input[type=range] { accent-color: var(--accent-color); }
        input[type="color"] { 
            -webkit-appearance: none; border: none; width: 32px; height: 32px; border-radius: 50%; overflow: hidden; cursor: pointer; padding: 0; background: none; 
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid var(--border-color); border-radius: 50%; }

        /* ============================================
           9. SPLASH SCREEN
           ============================================ */
        #splash-screen {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(135deg, #0d0d0a 0%, #1a1914 50%, #0d0d0a 100%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
            padding: 2rem;
            transition: opacity 0.8s ease-in-out;
            font-family: 'Courier New', monospace;
        }
        
        .splash-terminal {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 640px;
            background: rgba(0,0,0,0.2);
            border: 1px solid #2a2a20;
            border-radius: 0.5rem;
            padding: 1rem 1.5rem;
            order: 3;
        }
        
        .terminal-top-bar {
            /* hide window controls for minimal splash design */
            display: none;
        }
        .terminal-top-bar .dots { display: flex; gap: 6px; }
        .terminal-top-bar .dot { width: 12px; height: 12px; border-radius: 50%; }
        .terminal-top-bar .dot.r { background: #5c3d2e; }
        .terminal-top-bar .dot.y { background: #8b7355; }
        .terminal-top-bar .dot.g { background: #4a5d23; }
        .terminal-top-bar .title { 
            flex: 1; text-align: center; font-size: 11px; 
            color: #6b6b5a; letter-spacing: 0.15em; text-transform: uppercase;
        }
        
        .terminal-output {
            flex: 1;
            width: 100%;
            max-height: 120px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.6;
            color: #a0a090;
            padding-right: 0.5rem;
        }
        .terminal-output::-webkit-scrollbar { width: 4px; }
        .terminal-output::-webkit-scrollbar-thumb { background: #3d3d30; border-radius: 2px; }
        
        .log-line { 
            display: flex; gap: 12px; margin-bottom: 2px; 
            opacity: 0; animation: termFadeIn 0.2s forwards;
        }
        .log-time { color: #4a4a40; min-width: 65px; font-size: 10px; }
        .log-status { 
            min-width: 50px; font-weight: bold; font-size: 10px;
            padding: 1px 6px; border-radius: 3px; text-align: center;
        }
        .log-status.ok { color: #7cb342; background: rgba(124,179,66,0.15); }
        .log-status.load { color: #d4a03a; background: rgba(212,160,58,0.15); }
        .log-status.wait { color: #8b7355; background: rgba(139,115,85,0.15); }
        .log-status.err { color: #c62828; background: rgba(198,40,40,0.15); }
        .log-status.info { color: #5c9dc4; background: rgba(92,157,196,0.15); }
        .log-msg { color: #b0b0a0; }
        
        @keyframes termFadeIn { to { opacity: 1; } }
        @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }
        .cursor-blink::after { content: '‚ñà'; animation: blink 1s infinite; color: #d4a03a; }
        
        .terminal-input-line {
            display: flex; align-items: center; gap: 8px; padding-top: 1rem;
            border-top: 1px solid #2a2a20; margin-top: 1rem;
        }
        .terminal-prompt { color: #7cb342; font-weight: bold; }
        .terminal-input { color: #d4a03a; }
        
        .splash-sidebar {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 640px;
            background: transparent;
            padding: 0;
            order: 1;
        }
        
        .splash-logo-area {
            text-align: center;
            padding-bottom: 1rem;
        }
        .splash-logo-area h1 {
            font-family: 'Rubik', sans-serif;
            font-size: 2rem;
            font-weight: 900;
            color: #d4a03a;
            letter-spacing: 0.15em;
            margin: 0;
        }
        .splash-logo-area p {
            font-size: 10px;
            color: #6b6b5a;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            margin-top: 0.5rem;
        }
        
        #splash-globe-container {
            width: 180px;
            height: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 1rem;
        }
        #splash-globe-container canvas {
            max-width: 100%;
            max-height: 100%;
        }
        
        .splash-progress-area {
            width: 100%;
            max-width: 640px;
            padding-top: 1rem;
            border-top: 1px solid #2a2a20;
            order: 2;
        }
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .progress-header .label {
            font-size: 9px;
            color: #6b6b5a;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .progress-header .percent {
            font-size: 1.5rem;
            font-weight: bold;
            color: #d4a03a;
            font-family: 'Rubik', sans-serif;
        }
        .progress-track {
            height: 3px; background: #1a1a14; border-radius: 2px; overflow: hidden;
        }
        .progress-fill {
            height: 100%; width: 0%; 
            background: linear-gradient(90deg, #4a5d23, #7cb342, #d4a03a);
            transition: width 0.3s ease-out;
            box-shadow: 0 0 8px rgba(212,160,58,0.4);
        }
        
        .stage-indicators {
            display: flex; justify-content: space-between; margin-top: 1.5rem;
        }
        .stage-dot {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .stage-dot .dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2a2a20;
            transition: all 0.3s;
        }
        .stage-dot.complete .dot {
            background: #7cb342;
            box-shadow: 0 0 12px rgba(124, 179, 66, 0.6);
        }
        .stage-dot.active .dot {
            background: #d4a03a;
            box-shadow: 0 0 12px rgba(212, 160, 58, 0.6);
            animation: pulse-dot 1.5s infinite;
        }
        .stage-dot .label {
            font-size: 10px;
            color: #4a4a40;
            text-transform: uppercase;
        }
        @keyframes pulse-dot { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.3); } }

        .loading-spinner {
            border: 3px solid var(--border-color); border-left-color: var(--accent-color); border-radius: 50%;
            width: 32px; height: 32px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes pulse-glow { 0%, 100% { opacity: 0.4; } 50% { opacity: 0.7; } }
        .highlight-pulse { animation: pulse-glow 1.5s ease-in-out infinite; }

        /* ============================================
           10. QUIZ UI COMPONENTS
           ============================================ */
        /* Custom Dropdown */
        .custom-select-btn {
            width: 100%; padding: 0.75rem 1rem; border-radius: 0.75rem;
            background: rgba(0,0,0,0.3); border: 1px solid var(--border-color);
            color: var(--text-color); text-align: left; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            transition: all 0.2s;
        }
        .custom-select-btn:hover { border-color: var(--accent-color); background: rgba(0,0,0,0.5); }
        .custom-options {
            position: absolute; top: 100%; left: 0; width: 100%; max-height: 200px;
            overflow-y: auto; background: var(--panel-bg); border: 1px solid var(--border-color);
            border-radius: 0.75rem; margin-top: 0.5rem; z-index: 60; display: none;
            backdrop-filter: blur(20px); box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .custom-options.show { display: block; }
        .option-item {
            padding: 0.5rem 1rem; cursor: pointer; display: flex; align-items: center; gap: 0.75rem;
            transition: background 0.2s; font-size: 0.9rem;
        }
        .option-item:hover { background: rgba(255,255,255,0.1); }
        .option-item img { width: 1.25rem; height: auto; border-radius: 2px; }

        .theme-list-btn {
            display: block; width: 100%; text-align: left; padding: 8px 12px; margin-bottom: 4px;
            font-size: 11px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
            border: 1px solid var(--border-color); border-radius: 8px; opacity: 0.6; transition: 0.2s;
            background: rgba(255,255,255,0.02);
        }
        .theme-list-btn:hover { opacity: 1; background: rgba(255,255,255,0.1); border-color: var(--accent-color); }
        
        .size-btn {
            font-size: 10px; font-weight: bold; padding: 6px; border-radius: 4px;
            border: 1px solid var(--border-color); opacity: 0.5; transition: 0.2s; background: rgba(255,255,255,0.05);
            flex: 1; text-align: center;
        }
        .size-btn:hover { opacity: 0.8; }
        .size-btn.active { opacity: 1; background: var(--accent-color); color: black; border-color: var(--accent-color); }

        .nav-preset { transition: all 0.2s; border: 1px solid transparent; }
        .nav-preset.active { background: var(--accent-color); color: black; border-color: white; }
        
        .mcq-btn {
            background: rgba(0,0,0,0.6); border: 1px solid var(--border-color); color: var(--text-color); backdrop-filter: blur(4px);
        }
        .mcq-btn:hover { background: var(--accent-color); color: #000; }

        .mcq-flag-only {
            background: transparent !important; border: none !important; backdrop-filter: none !important; padding: 0 !important;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .mcq-flag-only:hover { transform: scale(1.15); filter: drop-shadow(0 0 10px var(--accent-color)); }
        .mcq-flag-only img { height: 100px !important; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); }

        /* --- Quiz Builder Buttons --- */
        .mode-btn {
            display: flex; align-items: center; gap: 0.75rem;
            padding: 0.875rem 1rem; border-radius: 0.75rem;
            background: rgba(255,255,255,0.05); border: 1px solid var(--border-color);
            color: var(--text-color); font-size: 0.875rem; font-weight: 500;
            cursor: pointer; transition: all 0.2s ease;
            text-align: left; width: 100%;
        }
        .mode-btn:hover { background: rgba(255,255,255,0.1); border-color: var(--accent-color); }
        .mode-btn.selected {
            background: var(--accent-color); color: var(--bg-color);
            border-color: var(--accent-color); font-weight: 700;
        }
        .mode-btn.selected svg { stroke: var(--bg-color); }
        .mode-btn svg { flex-shrink: 0; }

        .diff-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 1rem 0.5rem; border-radius: 0.75rem;
            background: rgba(255,255,255,0.05); border: 1px solid var(--border-color);
            color: var(--text-color); cursor: pointer; transition: all 0.2s ease;
            min-height: 70px;
        }
        .diff-btn:hover { background: rgba(255,255,255,0.1); border-color: var(--accent-color); }
        .diff-btn.selected {
            background: var(--accent-color); color: var(--bg-color);
            border-color: var(--accent-color);
        }
        .diff-btn.selected span { color: var(--bg-color); }

        .region-chip {
            padding: 0.5rem 1rem; border-radius: 9999px;
            background: rgba(255,255,255,0.05); border: 1px solid var(--border-color);
            color: var(--text-color); font-size: 0.75rem; font-weight: 600;
            cursor: pointer; transition: all 0.2s ease; text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .region-chip:hover { background: rgba(255,255,255,0.1); border-color: var(--accent-color); }
        .region-chip.selected {
            background: var(--accent-color); color: var(--bg-color);
            border-color: var(--accent-color);
        }

        .param-btn {
            flex: 1; padding: 0.5rem 0.25rem; border-radius: 0.5rem;
            background: rgba(255,255,255,0.05); border: 1px solid var(--border-color);
            color: var(--text-color); font-size: 0.75rem; font-weight: 600;
            cursor: pointer; transition: all 0.2s ease; text-align: center;
        }
        .param-btn:hover { background: rgba(255,255,255,0.1); border-color: var(--accent-color); }
        .param-btn.selected {
            background: var(--accent-color); color: var(--bg-color);
            border-color: var(--accent-color);
        }

        /* ============================================
           11. RADIAL MENU
           ============================================ */
        .radial-menu-container {
            position: relative; width: 600px; height: 600px; display: flex; align-items: center; justify-content: center;
        }
        .radial-item {
            position: absolute; width: 140px; height: 140px; border-radius: 50%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: var(--item-color); color: #1e293b;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer; transform: scale(0); opacity: 0;
            z-index: 10; text-align: center;
        }
        .radial-item:hover { transform: scale(1.15) !important; z-index: 20; box-shadow: 0 20px 40px rgba(0,0,0,0.4); }
        .radial-center-btn {
            width: 100px; height: 100px; border-radius: 50%;
            background: rgba(255,255,255,0.9); display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s; z-index: 30;
            box-shadow: 0 0 30px rgba(255,255,255,0.2);
        }
        .radial-center-btn:hover { transform: scale(1.1); background: white; }

        .quiz-drawer {
            position: absolute; top: 90%; left: 50%; transform: translateX(-50%);
            width: 200px; background: rgba(15,23,42,0.95); padding: 1rem; border-radius: 1rem;
            color: white; font-size: 0.75rem; pointer-events: none; opacity: 0;
            transition: all 0.2s; border: 1px solid rgba(255,255,255,0.1); margin-top: 10px;
            display: flex; flex-direction: column; gap: 0.5rem;
        }
        .radial-item:hover .quiz-drawer { opacity: 1; pointer-events: auto; }

        .toggle-btn {
            width: 40px; height: 20px; background: rgba(255,255,255,0.1); border-radius: 20px;
            position: relative; cursor: pointer; transition: 0.3s; border: 1px solid var(--border-color);
        }
        .toggle-btn.active { background: var(--accent-color); }
        .toggle-btn::after {
            content: ''; position: absolute; left: 2px; top: 2px; width: 14px; height: 14px;
            background: white; border-radius: 50%; transition: 0.3s;
        }
        .toggle-btn.active::after { left: 22px; }

        .hud-control-btn {
            width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
            background: rgba(255,255,255,0.1); cursor: pointer; transition: 0.2s; border: 1px solid transparent;
        }
        .hud-control-btn:hover { background: rgba(255,255,255,0.2); transform: scale(1.1); }
        
        /* Difficulty State Colors */
        .diff-easy-active { background: #22c55e !important; color: white; }
        .diff-med-active { background: #f97316 !important; color: white; }
        .diff-hard-active { background: #ef4444 !important; color: white; }
        .timer-active { border-color: var(--accent-color); color: var(--accent-color); }

        /* ============================================
           12. FEEDBACK & ANIMATIONS
           ============================================ */
        .feedback-success { color: #22c55e; text-shadow: 0 0 20px rgba(34, 197, 94, 0.8); }
        .feedback-fail { color: #ef4444; text-shadow: 0 0 20px rgba(239, 68, 68, 0.8); }
        
        /* Timer Ring */
        .timer-ring { position: relative; }
        .timer-ring svg { transform: rotate(-90deg); }
        .timer-ring circle { transition: stroke-dashoffset 0.1s linear; }
        
        /* MCQ Feedback */
        .mcq-correct { background: #22c55e !important; border-color: #22c55e !important; transform: scale(1.05); }
        .mcq-wrong { background: #ef4444 !important; border-color: #ef4444 !important; opacity: 0.5; }
        
        /* High Score */
        #high-score { font-size: 0.65rem; color: var(--accent-color); opacity: 0.8; }

        /* Country Name Label */
        #country-name-label {
            position: absolute; bottom: 8rem; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; opacity: 0; transition: opacity 0.3s;
            z-index: 25; text-shadow: 0 4px 10px rgba(0,0,0,0.8);
        }
        #country-name-label.visible { opacity: 1; }
        #country-name-text {
            font-size: 3rem; font-weight: 900; font-family: 'Rubik', sans-serif;
            text-transform: uppercase; letter-spacing: 0.05em; color: white;
            -webkit-text-stroke: 1px rgba(0,0,0,0.5);
        }

        /* ============================================
           13. UTILITIES
           ============================================ */
        details > summary { list-style: none; cursor: pointer; }
        details > summary::-webkit-details-marker { display: none; }

        /* Shake Animation for Wrong Answers */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }
        .shake { animation: shake 0.4s ease-in-out; }

        /* Score Increment Animation */
        @keyframes scoreUp {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: var(--accent-color); }
            100% { transform: scale(1); }
        }
        .score-animate { animation: scoreUp 0.3s ease-out; }

        /* Fade In/Out */
        .fade-in { animation: fadeIn 0.3s ease-out; }
        .fade-out { animation: fadeOut 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        /* ============================================
           CELEBRATION / CONFETTI EFFECTS
           ============================================ */
        #confetti-canvas {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9998;
        }

        .correct-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(34, 197, 94, 0.15);
            z-index: 9997;
            animation: correctPulse 0.3s ease-out;
            pointer-events: none;
        }

        .correct-overlay.fade-out {
            animation: fadeOut 0.5s ease-out forwards;
        }

        .correct-text {
            font-size: 4rem;
            font-weight: 900;
            color: #22c55e;
            text-shadow: 0 0 40px rgba(34, 197, 94, 0.9), 0 0 80px rgba(34, 197, 94, 0.5);
            animation: correctBounce 0.5s ease-out;
            font-family: var(--font-head);
            letter-spacing: 0.1em;
        }

        .correct-icon {
            font-size: 6rem;
            color: #22c55e;
            text-shadow: 0 0 40px rgba(34, 197, 94, 0.9);
            animation: correctBounce 0.5s ease-out 0.1s both;
        }

        @keyframes correctPulse {
            0% { background: rgba(34, 197, 94, 0.4); }
            100% { background: rgba(34, 197, 94, 0.15); }
        }

        @keyframes correctBounce {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* ============================================
           14. ACCESSIBILITY
           ============================================ */
        /* Reduced Motion - respect user preference */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        /* Focus Visible - keyboard navigation styling */
        :focus-visible {
            outline: 2px solid var(--accent-color);
            outline-offset: 2px;
        }

        /* Remove focus outline for mouse users */
        :focus:not(:focus-visible) {
            outline: none;
        }

        /* Skip to content link (hidden by default) */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--accent-color);
            color: var(--bg-color);
            padding: 8px 16px;
            z-index: 10000;
            font-weight: bold;
            transition: top 0.2s;
        }
        .skip-link:focus {
            top: 0;
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body class="theme-cyber">
    <!-- Skip link for keyboard navigation -->
    <a href="#hud-bar" class="skip-link">Skip to main content</a>

    <div id="canvas-container" role="img" aria-label="Interactive 3D globe"></div>

    <!-- Confetti Canvas for Celebrations -->
    <canvas id="confetti-canvas"></canvas>

    <!-- Splash Screen - Fullscreen Terminal -->
    <div id="splash-screen">
        <div class="splash-terminal">
            <div class="terminal-top-bar">
                <div class="dots">
                    <div class="dot r"></div>
                    <div class="dot y"></div>
                    <div class="dot g"></div>
                </div>
                <span class="title">System Initialization Protocol</span>
            </div>
            <div class="terminal-output" id="terminal-log">
                <div class="log-line" style="animation-delay: 0s">
                    <span class="log-time">[0.00s]</span>
                    <span class="log-status info">SYS</span>
                    <span class="log-msg">Geography Quiz v2.0 - Global Reconnaissance System</span>
                </div>
            </div>
            <div class="terminal-input-line">
                <span class="terminal-prompt">GEO://</span>
                <span class="terminal-input cursor-blink">initializing</span>
            </div>
        </div>
        
        <div class="splash-sidebar">
            <div class="splash-logo-area">
                <h1>GEOGRAPHY QUIZ</h1>
                <p>Ultimate Expedition</p>
            </div>
            
            <div id="splash-globe-container"></div>
            
            <div class="splash-progress-area">
                <div class="progress-header">
                    <span class="label">Loading Progress</span>
                    <span class="percent" id="progress-percent">0%</span>
                </div>
                <div class="progress-track">
                    <div class="progress-fill" id="splash-bar"></div>
                </div>
                <div class="stage-indicators">
                    <div class="stage-dot active" id="stage-core"><div class="dot"></div><span class="label">Core</span></div>
                    <div class="stage-dot" id="stage-texture"><div class="dot"></div><span class="label">Maps</span></div>
                    <div class="stage-dot" id="stage-geo"><div class="dot"></div><span class="label">Data</span></div>
                    <div class="stage-dot" id="stage-render"><div class="dot"></div><span class="label">Render</span></div>
                    <div class="stage-dot" id="stage-ready"><div class="dot"></div><span class="label">Ready</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Country Name Label -->
    <div id="country-name-label">
        <h1 id="country-name-text"></h1>
    </div>

    <!-- Container for 2D flag tags (persist across modes) -->
    <div id="tag-container"></div>

    <!-- Crosshair overlay -->
    <div id="crosshair">
        <div class="v-line"></div>
        <div class="h-line"></div>
        <div id="crosshair-center"></div>
        <div id="crosshair-coords"></div>
    </div>

    <!-- Login Modal -->
    <div id="login-modal" class="absolute inset-0 z-50 flex items-center justify-center transition-opacity duration-500 opacity-0 pointer-events-none">
        <div class="glass-panel p-10 rounded-[2rem] max-w-sm w-full text-center relative flex flex-col gap-6 shadow-2xl border-t border-white/20">
            <div class="space-y-1">
                <div class="inline-block p-3 rounded-full bg-white/5 mb-2 border border-white/10">
                    <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: var(--accent-color)"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                </div>
                <h1 class="text-3xl font-black font-head tracking-tight text-white">GEOGRAPHY QUIZ</h1>
                <p class="text-white/50 text-xs font-bold uppercase tracking-[0.2em]">Expedition Login</p>
            </div>
            
            <div id="login-form" class="flex flex-col gap-4 w-full text-left">
                <div class="space-y-1">
                    <label class="text-[10px] font-bold uppercase opacity-60 ml-1">Identity</label>
                    <input type="text" id="user-name" placeholder="Name" class="w-full font-bold">
                </div>
                
                <div class="space-y-1 relative">
                    <label class="text-[10px] font-bold uppercase opacity-60 ml-1">Origin</label>
                    <button id="country-select-btn" class="custom-select-btn font-bold group">
                        <span class="flex items-center gap-2" id="selected-country-display">
                            <span class="opacity-50">Select Country</span>
                        </span>
                        <svg class="w-4 h-4 opacity-50 group-hover:opacity-100 transition-opacity" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="country-dropdown-list" class="custom-options"></div>
                    <input type="hidden" id="user-country-val">
                </div>
            </div>

            <div class="space-y-3 w-full pt-2">
                <button id="login-btn" class="hidden w-full bg-white text-black font-black py-4 rounded-xl text-lg hover:scale-[1.02] active:scale-95 transition-all shadow-xl" style="background-color: var(--accent-color)">Play</button>
                <button id="guest-btn" class="hidden text-xs uppercase font-bold tracking-widest opacity-50 hover:opacity-100 transition-opacity">Continue as Guest</button>
            </div>
        </div>
    </div>

    <!-- Quiz Builder Modal -->
    <div id="quiz-builder" class="absolute inset-0 z-40 flex items-center justify-center hidden opacity-0 transition-opacity duration-300 backdrop-blur-md bg-black/70">
        <div class="glass-panel p-6 md:p-8 rounded-[2rem] max-w-3xl w-[95%] max-h-[90vh] overflow-y-auto">
            <!-- Header -->
            <div class="flex justify-between items-center border-b border-white/10 pb-4 mb-6">
                <h2 class="text-2xl md:text-3xl font-black uppercase tracking-tight">Mission Configuration</h2>
                <button onclick="closeQuizBuilder()" class="text-sm opacity-50 hover:opacity-100 transition-opacity">CLOSE [X]</button>
            </div>

            <!-- Mission Protocol: Given/Find -->
            <div class="mb-8">
                <h3 class="text-xs font-bold uppercase opacity-50 mb-4 tracking-widest">1. Mission Protocol</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Given (What's shown) -->
                    <div>
                        <label class="text-[10px] uppercase block text-center opacity-70 mb-3 tracking-wider">Information Given</label>
                        <div class="flex flex-col gap-2">
                            <button class="mode-btn given-btn selected" data-given="name" onclick="selectGiven('name', this)">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"></path></svg>
                                <span>Country Name</span>
                            </button>
                            <button class="mode-btn given-btn" data-given="flag" onclick="selectGiven('flag', this)">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 21v-4m0 0V5a2 2 0 012-2h6.5l1 1H21l-3 6 3 6h-8.5l-1-1H5a2 2 0 00-2 2zm9-13.5V9"></path></svg>
                                <span>Flag Ensign</span>
                            </button>
                            <button class="mode-btn given-btn" data-given="location" onclick="selectGiven('location', this)">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                                <span>Map Location</span>
                            </button>
                        </div>
                    </div>
                    <!-- Find (What player must do) -->
                    <div>
                        <label class="text-[10px] uppercase block text-center opacity-70 mb-3 tracking-wider">Objective To Find</label>
                        <div class="flex flex-col gap-2">
                            <button class="mode-btn find-btn selected" data-find="location" onclick="selectFind('location', this)">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path></svg>
                                <span>Locate on Map</span>
                            </button>
                            <button class="mode-btn find-btn" data-find="name" onclick="selectFind('name', this)">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                <span>Identify Name</span>
                            </button>
                            <button class="mode-btn find-btn" data-find="flag" onclick="selectFind('flag', this)">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 21v-4m0 0V5a2 2 0 012-2h6.5l1 1H21l-3 6 3 6h-8.5l-1-1H5a2 2 0 00-2 2zm9-13.5V9"></path></svg>
                                <span>Match Flag</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Difficulty -->
            <div class="mb-8">
                <h3 class="text-xs font-bold uppercase opacity-50 mb-4 tracking-widest">2. Clearance Level</h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-2">
                    <button class="diff-btn selected" data-diff="easy" onclick="selectDifficulty('easy', this)">
                        <span class="font-bold">Cadet</span>
                        <span class="text-[10px] opacity-60">Major Nations</span>
                    </button>
                    <button class="diff-btn" data-diff="medium" onclick="selectDifficulty('medium', this)">
                        <span class="font-bold">Officer</span>
                        <span class="text-[10px] opacity-60">Standard</span>
                    </button>
                    <button class="diff-btn" data-diff="hard" onclick="selectDifficulty('hard', this)">
                        <span class="font-bold">Spec Ops</span>
                        <span class="text-[10px] opacity-60">All Regions</span>
                    </button>
                    <button class="diff-btn" data-diff="expert" onclick="selectDifficulty('expert', this)">
                        <span class="font-bold">Expert</span>
                        <span class="text-[10px] opacity-60">No MCQ</span>
                    </button>
                </div>
            </div>

            <!-- Region Filter -->
            <div class="mb-8">
                <h3 class="text-xs font-bold uppercase opacity-50 mb-4 tracking-widest">3. Region Filter</h3>
                <div class="flex flex-wrap gap-2">
                    <button class="region-chip selected" data-region="all" onclick="toggleRegion('all', this)">All</button>
                    <button class="region-chip" data-region="africa" onclick="toggleRegion('africa', this)">Africa</button>
                    <button class="region-chip" data-region="asia" onclick="toggleRegion('asia', this)">Asia</button>
                    <button class="region-chip" data-region="europe" onclick="toggleRegion('europe', this)">Europe</button>
                    <button class="region-chip" data-region="northamerica" onclick="toggleRegion('northamerica', this)">N. America</button>
                    <button class="region-chip" data-region="southamerica" onclick="toggleRegion('southamerica', this)">S. America</button>
                    <button class="region-chip" data-region="oceania" onclick="toggleRegion('oceania', this)">Oceania</button>
                </div>
            </div>

            <!-- Mission Parameters -->
            <div class="mb-8">
                <h3 class="text-xs font-bold uppercase opacity-50 mb-4 tracking-widest">4. Mission Parameters</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <!-- Questions -->
                    <div>
                        <label class="text-[10px] uppercase block mb-2 opacity-60">Questions</label>
                        <div class="flex gap-1">
                            <button class="param-btn" data-count="10" onclick="selectQuestionCount(10, this)">10</button>
                            <button class="param-btn selected" data-count="25" onclick="selectQuestionCount(25, this)">25</button>
                            <button class="param-btn" data-count="50" onclick="selectQuestionCount(50, this)">50</button>
                            <button class="param-btn" data-count="all" onclick="selectQuestionCount('all', this)">All</button>
                        </div>
                    </div>
                    <!-- Timer -->
                    <div>
                        <label class="text-[10px] uppercase block mb-2 opacity-60">Time Limit</label>
                        <div class="flex gap-1">
                            <button class="param-btn selected" data-time="0" onclick="selectTimeLimit(0, this)">Off</button>
                            <button class="param-btn" data-time="5" onclick="selectTimeLimit(5, this)">5s</button>
                            <button class="param-btn" data-time="10" onclick="selectTimeLimit(10, this)">10s</button>
                            <button class="param-btn" data-time="15" onclick="selectTimeLimit(15, this)">15s</button>
                        </div>
                    </div>
                    <!-- Lives -->
                    <div>
                        <label class="text-[10px] uppercase block mb-2 opacity-60">Lives</label>
                        <div class="flex gap-1">
                            <button class="param-btn" data-lives="1" onclick="selectLives(1, this)">1</button>
                            <button class="param-btn selected" data-lives="3" onclick="selectLives(3, this)">3</button>
                            <button class="param-btn" data-lives="5" onclick="selectLives(5, this)">5</button>
                            <button class="param-btn" data-lives="unlimited" onclick="selectLives(Infinity, this)">&#8734;</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Start Button -->
            <button onclick="launchCustomMission()" class="w-full py-4 bg-[var(--accent-color)] text-[var(--bg-color)] font-black text-xl uppercase tracking-widest rounded-xl hover:brightness-110 shadow-lg transition-all">
                Initiate Mission
            </button>

            <!-- Quick Presets -->
            <div class="border-t border-white/10 pt-4 mt-6">
                <h3 class="text-xs font-bold uppercase opacity-50 mb-3 tracking-widest">Quick Presets</h3>
                <div class="flex flex-wrap gap-2">
                    <button onclick="quickPreset('locate')" class="px-3 py-2 bg-white/5 rounded-lg text-[10px] font-bold uppercase border border-white/10 hover:border-white/30 transition-colors">Find Country</button>
                    <button onclick="quickPreset('flaghunt')" class="px-3 py-2 bg-white/5 rounded-lg text-[10px] font-bold uppercase border border-white/10 hover:border-white/30 transition-colors">Flag Hunt</button>
                    <button onclick="quickPreset('identify')" class="px-3 py-2 bg-white/5 rounded-lg text-[10px] font-bold uppercase border border-white/10 hover:border-white/30 transition-colors">Name That Place</button>
                    <button onclick="quickPreset('master')" class="px-3 py-2 bg-white/5 rounded-lg text-[10px] font-bold uppercase border border-white/10 hover:border-white/30 transition-colors">Master Mode</button>
                    <button onclick="quickPreset('marathon')" class="px-3 py-2 bg-white/5 rounded-lg text-[10px] font-bold uppercase border border-white/10 hover:border-white/30 transition-colors">Marathon</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Radial Quiz Menu (Legacy - kept for quick access) -->
    <div id="quiz-menu" class="absolute inset-0 z-40 flex items-center justify-center hidden opacity-0 transition-opacity duration-300 backdrop-blur-sm bg-black/60">
        <div class="radial-menu-container" id="radial-menu">
            <div class="radial-center-btn" onclick="closeQuizMenu()">
                <svg class="w-8 h-8 text-slate-800" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </div>
            <!-- Radial items populated by JS -->
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="absolute inset-0 z-50 flex items-center justify-center bg-red-900/40 backdrop-blur-md hidden">
        <div class="glass-panel p-8 rounded-[2rem] max-w-md w-full text-center border-red-500/50 shadow-red-500/20 shadow-2xl">
            <h1 class="text-5xl font-black mb-2 text-white">MISSION FAILED</h1>
            <p class="text-red-300 mb-8 font-bold tracking-widest uppercase">Signal Lost</p>
            <div class="flex flex-col gap-3">
                <button onclick="restartGame()" class="w-full bg-white text-black font-bold py-3 rounded-xl hover:bg-gray-200 transition-colors">RETRY MISSION</button>
                <button onclick="openQuizBuilder()" class="w-full bg-black/40 text-white border border-white/20 font-bold py-3 rounded-xl hover:bg-white/10 transition-colors">CHANGE MISSION</button>
                <button onclick="exitToNav()" class="w-full text-xs uppercase font-bold tracking-widest opacity-60 hover:opacity-100 py-2">Return to Navigation</button>
            </div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div id="victory-modal" class="absolute inset-0 z-50 flex items-center justify-center bg-green-900/40 backdrop-blur-md hidden">
        <div class="glass-panel p-8 rounded-[2rem] max-w-md w-full text-center border-green-500/50 shadow-green-500/20 shadow-2xl">
            <div class="text-6xl mb-4">üèÜ</div>
            <h1 class="text-5xl font-black mb-2 text-white">MISSION COMPLETE</h1>
            <p class="text-green-300 mb-4 font-bold tracking-widest uppercase">All Targets Acquired</p>
            <div class="text-4xl font-black mb-8" style="color: var(--accent-color)"><span id="final-score">0</span> PTS</div>
            <div class="flex flex-col gap-3">
                <button onclick="restartGame()" class="w-full bg-green-500 text-black font-bold py-3 rounded-xl hover:bg-green-400 transition-colors">PLAY AGAIN</button>
                <button onclick="openQuizBuilder()" class="w-full bg-black/40 text-white border border-white/20 font-bold py-3 rounded-xl hover:bg-white/10 transition-colors">NEW MISSION</button>
                <button onclick="exitToNav()" class="w-full text-xs uppercase font-bold tracking-widest opacity-60 hover:opacity-100 py-2">Return to Navigation</button>
            </div>
        </div>
    </div>

    <!-- Pause Overlay -->
    <div id="pause-overlay" class="absolute inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-md hidden">
        <div class="glass-panel p-8 rounded-[2rem] max-w-sm w-full text-center">
            <svg class="w-16 h-16 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            <h1 class="text-4xl font-black mb-2 text-white">PAUSED</h1>
            <p class="text-white/50 mb-6 text-sm">Time remaining: <span id="pause-time-display" class="font-mono text-xl" style="color: var(--accent-color)">--</span>s</p>
            <button onclick="togglePause()" class="w-full bg-white text-black font-bold py-4 rounded-xl hover:bg-gray-200 transition-colors text-lg">RESUME</button>
            <button onclick="exitToNav()" class="w-full mt-3 text-xs uppercase font-bold tracking-widest opacity-60 hover:opacity-100 py-2">Quit Mission</button>
        </div>
    </div>

    <!-- Stats Panel -->
    <div id="stats-panel" class="absolute top-0 right-0 h-full w-96 z-50 pt-24 pb-8 pr-6 pointer-events-none transform translate-x-full transition-transform duration-300">
        <div class="glass-panel w-full h-full rounded-[2rem] p-6 overflow-y-auto pointer-events-auto shadow-2xl">
            <div class="flex justify-between items-center mb-6 border-b border-white/10 pb-4">
                <h2 class="text-xl font-bold">STATS & LEADERBOARD</h2>
                <button onclick="toggleStatsPanel()" class="opacity-50 hover:opacity-100">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            
            <div class="mb-6">
                <h3 class="text-sm font-bold opacity-60 uppercase mb-3">High Scores</h3>
                <div id="high-scores-list" class="space-y-2">
                    <div class="text-white/40 text-sm">No games played yet</div>
                </div>
            </div>
            
            <div class="mb-6">
                <h3 class="text-sm font-bold opacity-60 uppercase mb-3">Recent Games</h3>
                <div id="recent-games-list" class="space-y-2 max-h-64 overflow-y-auto">
                    <div class="text-white/40 text-sm">No recent games</div>
                </div>
            </div>
            
            <div>
                <h3 class="text-sm font-bold opacity-60 uppercase mb-3">Statistics</h3>
                <div class="grid grid-cols-2 gap-3 text-sm">
                    <div class="bg-white/5 rounded-lg p-3">
                        <div class="text-2xl font-black" id="stat-total-games">0</div>
                        <div class="text-xs opacity-50">Games Played</div>
                    </div>
                    <div class="bg-white/5 rounded-lg p-3">
                        <div class="text-2xl font-black" id="stat-total-score">0</div>
                        <div class="text-xs opacity-50">Total Score</div>
                    </div>
                    <div class="bg-white/5 rounded-lg p-3">
                        <div class="text-2xl font-black" id="stat-accuracy">0%</div>
                        <div class="text-xs opacity-50">Accuracy</div>
                    </div>
                    <div class="bg-white/5 rounded-lg p-3">
                        <div class="text-2xl font-black" id="stat-best-streak">0</div>
                        <div class="text-xs opacity-50">Best Streak</div>
                    </div>
                </div>
            </div>
            
            <button onclick="clearStats()" class="w-full mt-6 text-xs uppercase font-bold tracking-widest opacity-40 hover:opacity-100 py-2 border border-white/20 rounded-lg">Clear All Data</button>
        </div>
    </div>

    <!-- Top Bar -->
    <div class="absolute top-4 left-0 w-full flex justify-between px-8 pointer-events-none z-30 opacity-0 transition-opacity duration-500" id="top-ui">
        <div class="flex gap-4 pointer-events-auto">
            <button id="toggle-left" class="naked-btn" title="Country Index">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            </button>
            <button id="reset-cam" class="naked-btn" title="Reset View" onclick="resetView()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0zM2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
            </button>
            <button id="reset-globe" class="naked-btn" title="Reset Globe State" onclick="resetGlobeState()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
            </button>
        </div>

        <div id="hud-bar" class="glass-panel px-8 py-3 rounded-full flex items-center gap-8 pointer-events-auto">
            <button onclick="openQuizBuilder()" class="text-white hover:text-white/80 text-sm font-black uppercase tracking-widest transition-all hover:scale-105" style="text-shadow: 0 0 10px rgba(255,255,255,0.3)">
                <span id="quiz-btn-text">MISSION</span>
            </button>
            <div class="w-px h-8 bg-white/20"></div>
            <div class="flex items-center gap-6">
                <div id="global-diff-btn" class="hud-control-btn diff-med-active" title="Difficulty: Medium" onclick="toggleGlobalDifficulty()">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                </div>
                <div id="global-timer-btn" class="hud-control-btn relative" title="Timer: Off" onclick="toggleGlobalTimer()">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <span id="timer-badge" class="absolute -top-1 -right-1 text-[8px] bg-white text-black font-bold px-1 rounded-full hidden">0</span>
                </div>

                    <!-- Toggle error tracking; when disabled, wrong guesses will not count against lives. -->
                    <div id="error-toggle-btn" class="hud-control-btn error-on" title="Toggle Error Tracking" onclick="toggleErrorTracking()">ON</div>

                <div class="text-right">
                    <div class="text-[10px] opacity-60 uppercase font-bold">Score</div>
                    <div id="score-display" class="font-mono text-3xl font-black leading-none text-white">0</div>
                    <div id="high-score" class="hidden">Best: <span id="high-score-val">0</span></div>
                </div>
                <div class="flex flex-col items-end">
                    <div class="text-[10px] opacity-60 uppercase font-bold text-red-400">Errors</div>
                    <div class="font-mono text-3xl font-black leading-none text-red-400" id="lives-display">0/3</div>
                </div>
            </div>
            
            <div class="hidden md:block w-px h-8 bg-white/20"></div>
            <div id="active-mode-display" class="hidden md:block text-xs font-bold uppercase tracking-wider opacity-80" style="color: var(--accent-color)">NAVIGATION MODE</div>
            <div id="marathon-progress" class="hidden items-center gap-2 text-xs font-bold">
                <span class="opacity-60">Progress:</span>
                <span id="marathon-count" style="color: var(--accent-color)">0/0</span>
            </div>
            
            <div id="timer-ui" class="hidden flex items-center gap-2 text-white border-l border-white/20 pl-6">
                <div class="timer-ring">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="16" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="3"/>
                        <circle id="timer-progress" cx="20" cy="20" r="16" fill="none" stroke="var(--accent-color)" stroke-width="3" stroke-dasharray="100.53" stroke-dashoffset="0" stroke-linecap="round"/>
                    </svg>
                    <span id="countdown-display" class="absolute inset-0 flex items-center justify-center font-mono text-sm font-bold">--</span>
                </div>
            </div>

                <!-- Mode panel: slides down below the HUD bar to show current mode and icon -->
                <div id="mode-panel">Navigation Mode</div>
        </div>

        <div class="flex gap-2 pointer-events-auto">
            <button id="toggle-stats" class="naked-btn" title="Stats & Leaderboard" onclick="toggleStatsPanel()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            </button>
            <button id="pause-btn" class="naked-btn hidden" title="Pause Game" onclick="togglePause()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            </button>
            <button id="toggle-right" class="naked-btn" title="Settings">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.325.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 0 1 1.37.49l1.296 2.247a1.125 1.125 0 0 1-.26 1.431l-1.003.827c-.293.241-.438.613-.43.992a7.723 7.723 0 0 1 0 .255c-.008.378.137.75.43.991l1.004.827c.424.35.534.955.26 1.43l-1.298 2.247a1.125 1.125 0 0 1-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.47 6.47 0 0 1-.22.128c-.331.183-.581.495-.644.869l-.213 1.281c-.09.543-.56.94-1.11.94h-2.594c-.55 0-1.019-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 0 1-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 0 1-1.369-.49l-1.297-2.247a1.125 1.125 0 0 1 .26-1.431l1.004-.827c.292-.24.437-.613.43-.991a6.932 6.932 0 0 1 0-.255c.007-.38-.138-.751-.43-.992l-1.004-.827a1.125 1.125 0 0 1-.26-1.43l1.297-2.247a1.125 1.125 0 0 1 1.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.086.22-.128.332-.183.582-.495.644-.869l.214-1.28Z"/><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"/></svg>
            </button>
        </div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-panel" class="absolute top-0 left-0 h-full w-[22rem] min-w-[16rem] max-w-[40vw] side-panel z-20 pt-24 pb-8 pl-6 pointer-events-none" style="width:22rem;">
        <div class="glass-panel relative w-full h-full rounded-[2rem] overflow-hidden flex flex-col pointer-events-auto shadow-2xl">
            <!-- Resize handle on right edge -->
            <div id="left-handle" class="drag-handle"></div>
            <div class="p-5 border-b border-white/10 flex justify-between items-center">
                <h2 class="text-sm font-bold opacity-70 uppercase tracking-widest">Country Index</h2>
                <!-- Toggle flags button -->
                <button id="toggle-flags-btn" class="naked-btn" title="Show/Hide Flags">
                    <!-- flag icon -->
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 21v-8a2 2 0 012-2h14a2 2 0 012 2v8M3 13V6a2 2 0 012-2h14a2 2 0 012 2v7m-10-3h4"></path></svg>
                </button>
            </div>
            <div class="px-5 py-3 border-b border-white/10">
                <label class="text-[10px] uppercase font-bold opacity-60 mb-2 block">Flag Size</label>
                <div class="flex gap-1" id="size-controls">
                    <button class="size-btn" onclick="setFlagSize('S', this)">S</button>
                    <button class="size-btn active" onclick="setFlagSize('M', this)">M</button>
                    <button class="size-btn" onclick="setFlagSize('L', this)">L</button>
                    <button class="size-btn" onclick="setFlagSize('XL', this)">XL</button>
                </div>
            </div>
            <div id="country-list" class="flex-1 overflow-y-auto p-4 scroll-smooth"></div>
        </div>
    </div>

    <!-- Right Settings Panel -->
    <div id="right-panel" class="absolute top-0 right-0 h-full w-80 settings-panel z-20 pt-24 pb-8 pr-6 pointer-events-none">
        <div class="glass-panel w-full h-full rounded-[2rem] p-6 overflow-y-auto pointer-events-auto shadow-2xl">
            <h2 class="text-xl font-bold mb-6 opacity-90 border-b border-white/10 pb-2">SETTINGS</h2>
            <div class="flex gap-2 mb-4 border-b border-white/10 pb-2">
                <button class="settings-tab-btn flex-1 py-1 text-xs font-bold uppercase tracking-wider opacity-50 hover:opacity-100 transition-all active-tab" data-tab="nav">Nav</button>
                <button class="settings-tab-btn flex-1 py-1 text-xs font-bold uppercase tracking-wider opacity-50 hover:opacity-100 transition-all" data-tab="style">Style</button>
            </div>
            <!-- Nav -->
            <div id="tab-nav" class="space-y-6">
                <div>
                    <label class="text-xs font-bold opacity-60 uppercase mb-2 block">Sensitivity Preset</label>
                    <div class="flex gap-2">
                        <button class="nav-preset w-full py-2 bg-white/10 rounded text-xs font-bold hover:bg-white/20" data-val="low">Low</button>
                        <button class="nav-preset active w-full py-2 bg-white/10 rounded text-xs font-bold hover:bg-white/20" data-val="med">Med</button>
                        <button class="nav-preset w-full py-2 bg-white/10 rounded text-xs font-bold hover:bg-white/20" data-val="high">High</button>
                    </div>
                </div>
                <details class="group">
                    <summary class="flex justify-between items-center font-bold cursor-pointer list-none text-xs uppercase opacity-70 hover:opacity-100 mt-4 rounded">
                        <span>ADVANCED</span>
                        <span class="transition group-open:rotate-180"><svg fill="none" height="16" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24" width="16"><path d="M6 9l6 6 6-6"></path></svg></span>
                    </summary>
                    <div class="text-neutral-600 mt-4 group-open:animate-fadeIn space-y-4 pl-2 border-l border-white/10">
                        <div><label class="text-[10px] text-white/60 uppercase">Rotate Speed</label><input type="range" id="nav-speed" min="0.1" max="2.0" step="0.1" class="w-full mt-1"></div>
                        <div><label class="text-[10px] text-white/60 uppercase">Zoom Speed</label><input type="range" id="nav-zoom" min="0.1" max="2.0" step="0.1" class="w-full mt-1"></div>
                        <div><label class="text-[10px] text-white/60 uppercase">Damping</label><input type="range" id="nav-damping" min="0.01" max="0.3" step="0.01" class="w-full mt-1"></div>
                        <div><label class="text-[10px] text-white/60 uppercase">Auto-Rotate</label><input type="range" id="nav-autorotate" min="0" max="5.0" step="0.5" class="w-full mt-1"></div>
                        <div><label class="text-[10px] text-white/60 uppercase">Min Dist</label><input type="range" id="nav-min" min="11" max="20" step="1" class="w-full mt-1"></div>
                        <div><label class="text-[10px] text-white/60 uppercase">Max Dist</label><input type="range" id="nav-max" min="20" max="100" step="5" class="w-full mt-1"></div>
                    </div>
                </details>
            </div>
            <!-- Style -->
            <div id="tab-style" class="space-y-5 hidden">
                 <div>
                    <label class="text-xs font-bold opacity-60 uppercase mb-2 block">UI Theme</label>
                    <div class="flex flex-col gap-1">
                        <button class="theme-list-btn" onclick="setTheme('cyber')">Cyber</button>
                        <button class="theme-list-btn" onclick="setTheme('royal')">Royal</button>
                        <button class="theme-list-btn" onclick="setTheme('terminal')">Terminal</button>
                        <button class="theme-list-btn" onclick="setTheme('paper')">Cartographer</button>
                        <button class="theme-list-btn" onclick="setTheme('midnight')">Midnight</button>
                        <button class="theme-list-btn" onclick="setTheme('navy')">Navy</button>
                    </div>
                </div>
                <div class="flex items-center justify-between">
                    <label class="text-xs font-bold opacity-60 uppercase">Lat/Long Grid</label>
                    <div id="toggle-graticule" class="toggle-btn active" onclick="toggleSwitch(this, 'graticule')"></div>
                </div>
                <div class="flex items-center justify-between">
                    <label class="text-xs font-bold opacity-60 uppercase">Borders</label>
                    <div id="toggle-borders" class="toggle-btn active" onclick="toggleSwitch(this, 'borders')"></div>
                </div>
                <div class="flex items-center justify-between">
                    <label class="text-xs font-bold opacity-60 uppercase">Border Color</label>
                    <input type="color" id="border-color-picker" value="#ffffff">
                </div>
                <div>
                    <label class="text-xs font-bold opacity-60 uppercase">Border Opacity</label>
                    <input type="range" id="border-thickness" min="1" max="10" step="0.5" value="5" class="w-full mt-2 h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                    <p class="text-[9px] opacity-40 mt-1">Note: Line width limited by WebGL</p>
                </div>
                <!-- Crosshair style controls -->
                <div class="flex items-center justify-between">
                    <label class="text-xs font-bold opacity-60 uppercase">Crosshair Shape</label>
                    <select id="crosshair-shape-select" class="bg-transparent border border-white/30 rounded px-2 py-1 text-xs" title="Choose crosshair shape">
                        <option value="square">Square</option>
                        <option value="circle">Circle</option>
                    </select>
                </div>
                <div class="flex items-center justify-between">
                    <label class="text-xs font-bold opacity-60 uppercase">Show Coordinates</label>
                    <div id="toggle-crosshair-coords" class="toggle-btn active" onclick="toggleSwitch(this, 'crosshairCoords')"></div>
                </div>
                <!-- Crosshair color picker -->
                <div class="flex items-center justify-between mt-2">
                    <label class="text-xs font-bold opacity-60 uppercase">Crosshair Color</label>
                    <input type="color" id="crosshair-color-picker" value="#38bdf8" class="w-16 h-6 rounded border border-white/30">
                </div>
                <!-- Crosshair font size slider -->
                <div class="flex items-center justify-between mt-2">
                    <label class="text-xs font-bold opacity-60 uppercase">Crosshair Font Size</label>
                    <input type="range" id="crosshair-font-slider" min="6" max="20" step="1" value="10" class="w-full mt-2 h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Enable/Disable crosshair -->
                <div class="flex items-center justify-between mt-2">
                    <label class="text-xs font-bold opacity-60 uppercase">Enable Crosshair</label>
                    <div id="toggle-crosshair-enable" class="toggle-btn active" onclick="toggleSwitch(this, 'crosshairEnable')"></div>
                </div>

                <!-- Coordinates vertical offset slider -->
                <div class="flex items-center justify-between mt-2">
                    <label class="text-xs font-bold opacity-60 uppercase">Coords Offset Y</label>
                    <input type="range" id="coords-offset-slider" min="-50" max="50" step="1" value="0" class="w-full mt-2 h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Coordinates horizontal offset slider -->
                <div class="flex items-center justify-between mt-2">
                    <label class="text-xs font-bold opacity-60 uppercase">Coords Offset X</label>
                    <input type="range" id="coords-offset-x-slider" min="-50" max="50" step="1" value="0" class="w-full mt-2 h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Advanced rendering options -->
                <div class="mt-4 pt-2 border-t border-white/20">
                    <label class="text-xs font-bold uppercase opacity-60 block mb-2">Advanced Rendering</label>
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-xs font-bold opacity-60 uppercase">Atmosphere</span>
                        <div class="toggle-btn active" id="toggle-atmosphere" onclick="toggleSwitch(this, 'atmosphere')"></div>
                    </div>
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-xs font-bold opacity-60 uppercase">Sunlight</span>
                        <div class="toggle-btn active" id="toggle-sunlight" onclick="toggleSwitch(this, 'sunLight')"></div>
                    </div>
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-xs font-bold opacity-60 uppercase">Decorative Rings</span>
                        <div class="toggle-btn active" id="toggle-rings" onclick="toggleSwitch(this, 'rings')"></div>
                    </div>

                    <!-- Environment map toggle -->
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-xs font-bold opacity-60 uppercase">Environment</span>
                        <div class="toggle-btn" id="toggle-environment" onclick="toggleSwitch(this, 'environment')"></div>
                    </div>
                    <!-- Ray tracing toggle (placeholder) -->
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-xs font-bold opacity-60 uppercase">Raytracing</span>
                        <div class="toggle-btn" id="toggle-raytracing" onclick="toggleSwitch(this, 'raytracing')"></div>
                    </div>
                </div>
                <div>
                    <label class="text-xs font-bold opacity-60 uppercase">Border Thickness</label>
                    <input type="range" id="border-width-slider" min="1" max="10" step="0.5" value="1" class="w-full mt-2 h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                </div>
                <div>
                    <label class="text-xs font-bold opacity-60 uppercase">UI Panel Thickness</label>
                    <input type="range" id="ui-border-width" min="0" max="8" step="1" value="2" class="w-full mt-2 h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- About section providing credits and information about data sources -->
                <div class="mt-6 pt-4 border-t border-white/20">
                    <h3 class="text-xs font-bold uppercase opacity-60 mb-2">About This Project</h3>
                    <p class="text-xs leading-relaxed text-white/70">
                        The <strong>Ultimate Expedition</strong> geography quiz is an educational experience built with <strong>Three.js</strong> for 3D rendering and <strong>Tailwind¬†CSS</strong> for styling. Country outlines and borders come from the open&nbsp;source <em>Natural¬†Earth</em> dataset, while flags are delivered by <em>FlagCDN</em>. This project is for learning and entertainment only and is not affiliated with any official geography institution. Enjoy your journey around the world!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Game Panel -->
    <div class="absolute bottom-10 w-full flex justify-center pointer-events-none z-30">
        <div id="game-panel" class="naked-panel px-4 py-4 pointer-events-auto transform transition-all duration-500 translate-y-40 opacity-0 w-auto inline-flex flex-col items-center max-w-[95vw] relative">
            <!-- Exit Button -->
            <button id="exit-quiz-btn" onclick="exitToNav()" class="absolute -top-12 right-0 bg-red-500/80 hover:bg-red-500 text-white rounded-full w-10 h-10 flex items-center justify-center transition-all hover:scale-110 shadow-lg" title="Exit Quiz">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
            <div id="prompt-container" class="flex flex-col md:flex-row items-center gap-12 justify-center w-full">
                <div id="flag-display" class="hidden shrink-0 filter drop-shadow-2xl transition-all">
                    <img id="flag-img" src="" class="h-28 w-auto object-contain transform hover:scale-110 transition-transform">
                </div>
                <div class="text-center md:text-left whitespace-nowrap text-shadow-strong">
                    <h2 id="main-question" class="text-4xl md:text-6xl font-black text-white leading-none mb-2">Initializing...</h2>
                    <p id="sub-question" class="font-bold text-lg tracking-[0.2em] uppercase" style="color: var(--accent-color)">System Standby</p>
                </div>
            </div>
            <div id="input-area" class="w-full flex flex-col items-center gap-6 mt-8 transition-all">
                <form id="type-form" class="w-full hidden">
                    <input type="text" id="answer-input" placeholder="TYPE NAME" class="w-96 px-8 py-4 rounded-full text-center text-xl font-bold bg-black/40 border border-white/40 focus:w-[32rem] transition-all backdrop-blur-md text-shadow-strong">
                </form>
                <div id="mcq-grid" class="hidden grid grid-cols-2 gap-6 w-full max-w-2xl"></div>
                <div class="flex flex-col items-center gap-3">
                    <div id="feedback" class="h-8 text-xl font-bold text-center tracking-widest uppercase transition-all duration-300 text-shadow-strong"></div>
                </div>
            </div>
        </div>
    </div>

    <button id="skip-btn" class="absolute bottom-8 right-8 z-40 bg-white/10 hover:bg-white/20 text-white/80 border-2 border-white/20 px-6 py-3 rounded-full text-sm font-bold uppercase tracking-widest transition-all hidden backdrop-blur-md hover:scale-105 pointer-events-auto">Skip Mission ‚Üí</button>

    <script>
        /* ============================================
           GLOBE MAP QUIZ - JAVASCRIPT
           ============================================
           Table of Contents:
           1. Configuration
           2. State Management
           3. Utility Systems (Terminal, Cache, Stats)
           4. Three.js Setup (Scene, Camera, Renderer)
           5. Globe & Shader System
           6. Quiz Engine
           7. UI Controllers
           8. Event Handlers
           9. Animation Loop
           10. Initialization
           ============================================ */

        /* ============================================
           1. CONFIGURATION
           ============================================ */
        const CONFIG = {
            // High-res Earth textures (8K)
            textureUrl: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-blue-marble.jpg',
            bumpMapUrl: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-topology.png',
            // High detail borders (10m resolution)
            geoJsonUrl: 'https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_10m_admin_0_countries.geojson',
            highlightColor: 0x38bdf8,
            // Globe settings
            globeRadius: 10,
            atmosphereRadius: 10.5,
            // Performance settings
            maxTextureSize: 8192,
            flagAtlasSize: 8192
        };

        console.log('Globe Quiz initializing...');

        /* ============================================
           3. UTILITY SYSTEMS
           ============================================ */
        // --- Performance Utilities ---
        function debounce(fn, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        function throttle(fn, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    fn.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        // Memoization utility for expensive computations
        function memoize(fn) {
            const cache = new Map();
            return function(...args) {
                const key = JSON.stringify(args);
                if (cache.has(key)) return cache.get(key);
                const result = fn.apply(this, args);
                cache.set(key, result);
                return result;
            };
        }

        // Terminal Logging System
        const TERMINAL = {
            startTime: Date.now(),
            log: function(status, msg) {
                const terminal = document.getElementById('terminal-log');
                if (!terminal) return;
                const elapsed = ((Date.now() - this.startTime) / 1000).toFixed(2);
                const time = `[${elapsed}s]`;
                const line = document.createElement('div');
                line.className = 'log-line';
                line.innerHTML = `<span class="log-time">${time}</span><span class="log-status ${status}">${status.toUpperCase()}</span><span class="log-msg">${msg}</span>`;
                terminal.appendChild(line);
                terminal.scrollTop = terminal.scrollHeight;
                
                // Update input line
                const inputEl = document.querySelector('.terminal-input');
                if (inputEl) inputEl.textContent = msg.substring(0, 30) + (msg.length > 30 ? '...' : '');
            },
            setStage: function(stageId) {
                document.querySelectorAll('.stage-dot').forEach(el => {
                    if (el.classList.contains('active')) {
                        el.classList.remove('active');
                        el.classList.add('complete');
                    }
                });
                const stage = document.getElementById(stageId);
                if (stage) stage.classList.add('active');
            },
            setProgress: function(pct) {
                const bar = document.getElementById('splash-bar');
                const label = document.getElementById('progress-percent');
                if (bar) bar.style.width = pct + '%';
                if (label) label.textContent = Math.round(pct) + '%';
            }
        };
        
        // Create animated splash globe
        function createSplashGlobe() {
            const container = document.getElementById('splash-globe-container');
            if (!container) return;
            
            const width = 300, height = 300;
            const splashScene = new THREE.Scene();
            const splashCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            splashCamera.position.z = 3;
            
            const splashRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            splashRenderer.setSize(width, height);
            splashRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(splashRenderer.domElement);
            
            // Wireframe globe
            const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
            const wireframeMat = new THREE.MeshBasicMaterial({ 
                color: 0xd4a03a, wireframe: true, transparent: true, opacity: 0.3 
            });
            const wireGlobe = new THREE.Mesh(sphereGeo, wireframeMat);
            splashScene.add(wireGlobe);
            
            // Inner solid sphere
            const innerMat = new THREE.MeshBasicMaterial({ color: 0x1a1914 });
            const innerGlobe = new THREE.Mesh(new THREE.SphereGeometry(0.95, 32, 32), innerMat);
            splashScene.add(innerGlobe);
            
            // Points on surface
            const pointsGeo = new THREE.BufferGeometry();
            const pointPositions = [];
            for (let i = 0; i < 200; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pointPositions.push(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(phi) * Math.sin(theta),
                    Math.cos(phi)
                );
            }
            pointsGeo.setAttribute('position', new THREE.Float32BufferAttribute(pointPositions, 3));
            const pointsMat = new THREE.PointsMaterial({ color: 0x7cb342, size: 0.03 });
            splashScene.add(new THREE.Points(pointsGeo, pointsMat));
            
            // Orbit ring
            const ringGeo = new THREE.TorusGeometry(1.3, 0.01, 8, 64);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xd4a03a, transparent: true, opacity: 0.5 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 3;
            splashScene.add(ring);
            
            // Animate
            function animateSplash() {
                if (!document.getElementById('splash-screen')) return;
                requestAnimationFrame(animateSplash);
                wireGlobe.rotation.y += 0.005;
                innerGlobe.rotation.y += 0.005;
                ring.rotation.z += 0.01;
                splashRenderer.render(splashScene, splashCamera);
            }
            animateSplash();
        }
        createSplashGlobe();
        
        TERMINAL.log('ok', 'Core systems initialized');

        // Flag cache system with preloading
        const FLAG_CACHE = {
            images: new Map(),
            loading: new Set(),
            
            get: function(iso) {
                return this.images.get(iso.toLowerCase());
            },
            
            preload: function(iso) {
                const key = iso.toLowerCase();
                if (this.images.has(key) || this.loading.has(key)) {
                    return this.images.has(key) ? Promise.resolve(this.images.get(key)) : new Promise(r => setTimeout(() => r(this.get(key)), 100));
                }
                
                this.loading.add(key);
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        this.images.set(key, img);
                        this.loading.delete(key);
                        resolve(img);
                    };
                    img.onerror = () => {
                        this.loading.delete(key);
                        resolve(null);
                    };
                    // Use a moderately high resolution flag (w640) for good clarity on the
                    // globe.  A 640‚Äëpixel width is supported for most flags.  If a flag
                    // does not have a 640‚Äëwidth variant, the CDN will downscale from
                    // the highest available resolution automatically.  Higher resolutions
                    // such as 2560 can be used but may drastically increase download
                    // time without noticeable quality improvements on typical screens.
                    img.src = `https://flagcdn.com/w640/${key}.png`;
                });
            },
            
            preloadAll: async function(countries, onProgress) {
                const total = countries.length;
                let loaded = 0;
                const batchSize = 20; // Larger batches for speed
                
                for (let i = 0; i < countries.length; i += batchSize) {
                    const batch = countries.slice(i, i + batchSize);
                    await Promise.all(batch.map(c => this.preload(c.iso)));
                    loaded += batch.length;
                    if (onProgress) onProgress(Math.min(loaded, total), total);
                }
            }
        };

        // Persistent flag texture system - draws found flags onto a master texture
        const FLAG_RENDER = {
            canvas: null,
            ctx: null,
            texture: null,
            countryFlags: new Map(), // countryId -> {iso, bounds}
            
            init: function(renderer) {
                // Initialise a very large canvas to hold all persistent flags.  An
                // 8k √ó 4k resolution atlas ensures neighbouring flags remain
                // crisp when zoomed in and reduces visible pixelation.  The
                // canvas is cleared initially to transparent.  This texture
                // persists for the lifetime of the application and grows as
                // more countries are marked found.
                this.canvas = document.createElement('canvas');
                this.canvas.width = 8192;
                this.canvas.height = 4096;
                this.ctx = this.canvas.getContext('2d');
                this.ctx.fillStyle = 'rgba(0,0,0,0)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.texture = new THREE.CanvasTexture(this.canvas);
                // Use linear filtering and anisotropy to improve appearance of
                // downsampled flags.  Without anisotropy distant flags can
                // appear blurry or aliased.
                this.texture.minFilter = THREE.LinearFilter;
                this.texture.magFilter = THREE.LinearFilter;
                this.texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                this.texture.needsUpdate = true;
            },
            
            addFlag: async function(country) {
                // Draw a flag into the atlas with a slight margin to prevent
                // bleeding across borders.  Before drawing the new flag,
                // explicitly clear the target region so that previously drawn
                // neighbouring flags do not blend through.  This ensures
                // crisp boundaries when multiple persistent flags overlap in
                // adjacent countries.

                // Try cached image first, or wait for it to load
                let cachedImg = FLAG_CACHE.get(country.iso);
                if (!cachedImg) {
                    // Wait for the image to load
                    cachedImg = await FLAG_CACHE.preload(country.iso);
                }
                if (!cachedImg) {
                    // Failed to load - draw a placeholder colored rectangle
                    console.warn(`Failed to load flag for ${country.name} (${country.iso})`);
                    const b = country.bounds;
                    const totalW = this.canvas.width;
                    const totalH = this.canvas.height;
                    let x = ((b.minX + 180) / 360) * totalW;
                    let y = ((90 - b.maxY) / 180) * totalH;
                    let w = ((b.maxX - b.minX) / 360) * totalW;
                    let h = ((b.maxY - b.minY) / 180) * totalH;
                    if (w <= 0 || h <= 0) return;
                    const marginFactor = 0.6;
                    const newW = w * marginFactor;
                    const newH = h * marginFactor;
                    const newX = x + (w - newW) / 2;
                    const newY = y + (h - newH) / 2;
                    // Draw a gray placeholder
                    this.ctx.fillStyle = '#4b5563';
                    this.ctx.fillRect(newX, newY, newW, newH);
                    this.texture.needsUpdate = true;
                    this.countryFlags.set(country.id, { iso: country.iso, bounds: b });
                    return;
                }

                const b = country.bounds;
                // Convert geo bounds to pixel coords (equirectangular projection)
                const totalW = this.canvas.width;
                const totalH = this.canvas.height;
                let x = ((b.minX + 180) / 360) * totalW;
                let y = ((90 - b.maxY) / 180) * totalH;
                let w = ((b.maxX - b.minX) / 360) * totalW;
                let h = ((b.maxY - b.minY) / 180) * totalH;
                // If the flag is extremely small, skip to avoid artifacts
                if (w <= 0 || h <= 0) return;
                // Apply a margin so the flag doesn't bleed into neighbouring countries
                // Use a stronger margin between neighbouring flags.  A lower
                // marginFactor shrinks the drawing area further to prevent
                // overlaps when multiple adjacent countries persist flags.  A
                // value of 0.6 leaves a generous buffer.
                const marginFactor = 0.6;
                const newW = w * marginFactor;
                const newH = h * marginFactor;
                const newX = x + (w - newW) / 2;
                const newY = y + (h - newH) / 2;
                // Clear the region before drawing the new flag
                this.ctx.clearRect(newX - 2, newY - 2, newW + 4, newH + 4);
                this.ctx.drawImage(cachedImg, newX, newY, newW, newH);
                this.texture.needsUpdate = true;
                this.countryFlags.set(country.id, { iso: country.iso, bounds: b });
            },
            
            clear: function() {
                // Clear the entire atlas using its actual dimensions rather than
                // hard-coded values.  This prevents leftover artifacts when the
                // atlas size changes.
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.texture.needsUpdate = true;
                this.countryFlags.clear();
            }
        };

        // Game statistics
        const STATS = {
            games: JSON.parse(localStorage.getItem('geoQuizStats') || '[]'),
            
            record: function(mode, score, correct, total, time) {
                const entry = {
                    date: new Date().toISOString(),
                    mode: mode,
                    score: score,
                    correct: correct,
                    total: total,
                    time: time,
                    user: STATE.userName
                };
                this.games.unshift(entry);
                if (this.games.length > 100) this.games = this.games.slice(0, 100);
                localStorage.setItem('geoQuizStats', JSON.stringify(this.games));
            },
            
            getHighScore: function(mode) {
                const modeGames = this.games.filter(g => g.mode === mode);
                if (modeGames.length === 0) return 0;
                return Math.max(...modeGames.map(g => g.score));
            },
            
            getLeaderboard: function() {
                return this.games.slice(0, 20);
            }
        };

        const SVGS = {
            target: `<svg class="quiz-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path></svg>`,
            question: `<svg class="quiz-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`,
            flag: `<svg class="quiz-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 21v-8a2 2 0 012-2h14a2 2 0 012 2v8M3 13V6a2 2 0 012-2h14a2 2 0 012 2v7m-10-3h4"></path></svg>`,
            reverse: `<svg class="quiz-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>`,
            master: `<svg class="quiz-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg>`,
            global: `<svg class="quiz-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`,
        };

        // Quiz Mode Definitions
        const MODES = {
            1: { name: "Locate", desc: "Find the requested country.", icon: SVGS.target, color: "#38bdf8" },
            2: { name: "Identify", desc: "Name the highlighted country.", icon: SVGS.question, color: "#a855f7" },
            3: { name: "Flag Match", desc: "Match flag to country.", icon: SVGS.flag, color: "#f472b6" },
            4: { name: "Rev. Locate", desc: "Find country by flag.", icon: SVGS.reverse, color: "#fb923c" },
            5: { name: "Master", desc: "Type name of country.", icon: SVGS.master, color: "#34d399" },
            6: { name: "Marathon", desc: "Find all countries.", icon: SVGS.global, color: "#ef4444" }
        };

        /* ============================================
           2. STATE MANAGEMENT
           ============================================ */
        const STATE = {
            loggedIn: false, userName: "Guest", userCountry: "Unknown", mode: 0,
            countries: [], targetIndex: -1, score: 0, falseGuesses: 0, maxLives: 3, 
            globalDifficulty: 'medium', globalTimeLimit: 0,
            found: new Set(), results: {}, startTime: 0,
            mapWidth: 4096, mapHeight: 2048, mapData: null,
            statusData: new Uint8Array(256), statusTexture: null,
            flagCanvas: null, flagCtx: null, flagTexture: null,
            sidebarLocked: false, currentTheme: 'cyber', isFlying: false,
            questionStartTime: 0, timerInterval: null,
            highScores: JSON.parse(localStorage.getItem('geoQuizHighScores') || '{}'),
            borderGroup: null,
            borderMaterial: null,
            isPaused: false, pauseTimeRemaining: 0,
            correctCount: 0, totalQuestions: 0,
            gameStartTime: 0,
            multiplayer: {
                enabled: false,
                roomCode: null,
                isHost: false,
                opponentScore: 0,
                opponentName: "Opponent"
            }
        };

        // Extend the STATE object with additional runtime properties used for
        // improved flag rendering and sidebar interactions.
        STATE.flagSprites = {};
        STATE.tagElements = {};
        STATE.selectedCountryId = null;
        STATE.showFlags = true;
        // Store the base max lives so error tracking can toggle between finite and infinite lives
        STATE.baseMaxLives = STATE.maxLives;
        // Track error state
        STATE.trackErrors = true;
        // Quiz pool - filtered list of countries for current quiz session
        STATE.quizPool = [];
        STATE.quizPoolIndex = 0;

        // Quiz Builder Configuration - tracks current builder selections
        const QuizConfig = {
            given: 'name',       // 'name' | 'flag' | 'location'
            find: 'location',    // 'name' | 'flag' | 'location'
            difficulty: 'easy',  // 'easy' | 'medium' | 'hard' | 'expert'
            regions: ['all'],    // Array of selected regions
            questionCount: 25,   // Number or 'all'
            timeLimit: 0,        // Seconds per question (0 = unlimited)
            lives: 3             // Number or Infinity
        };

        /* ============================================
           4. THREE.JS SETUP
           ============================================ */
        const scene = new THREE.Scene();
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8); sunLight.position.set(50, 30, 50); scene.add(sunLight);
        const backLight = new THREE.DirectionalLight(0x445588, 0.4); backLight.position.set(-50, -10, -50); scene.add(backLight);

        const starsGeo = new THREE.BufferGeometry();
        const posArray = new Float32Array(2000 * 3);
        for(let i=0; i<6000; i++) posArray[i] = (Math.random() - 0.5) * 500;
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        scene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({size: 0.5, color: 0xffffff, transparent: true, opacity: 0.8})));

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25; camera.position.y = 10;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.minDistance = 12; controls.maxDistance = 60;
        controls.autoRotate = true; controls.autoRotateSpeed = 0.5;
        controls.addEventListener('start', () => { STATE.isFlying = false; }); 

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Globe Group
        const globeGroup = new THREE.Group(); scene.add(globeGroup);
        const earthMat = new THREE.MeshPhongMaterial({ 
            color: 0xffffff, 
            shininess: 15, 
            specular: 0x333333, 
            emissive: 0x000511, 
            emissiveIntensity: 0.2,
            bumpScale: 0.015
        });

        // Expose the earth material globally so other components (e.g. environment toggle) can modify it.
        STATE.earthMaterial = earthMat;
        
        // Loader Manager for Splash Screen
        const manager = new THREE.LoadingManager();
        const textureLoader = new THREE.TextureLoader(manager);
        
        // Forward declarations for loading state
        let textureLoaded = false;
        let geoDataLoaded = false;
        let flagsLoaded = false;
        
        function checkLoadStatus() {
            console.log('checkLoadStatus:', {textureLoaded, geoDataLoaded, flagsLoaded});
            if (textureLoaded && geoDataLoaded && flagsLoaded) {
                TERMINAL.setProgress(100);
                TERMINAL.setStage('stage-ready');
                TERMINAL.log('ok', 'All systems operational');
                TERMINAL.log('ok', 'Launching interface...');
                
                setTimeout(() => {
                    const splash = document.getElementById('splash-screen');
                    if (splash) splash.style.opacity = '0';
                    setTimeout(() => {
                        if (splash) splash.style.display = 'none';
                        const loginModal = document.getElementById('login-modal');
                        if (loginModal) loginModal.classList.remove('opacity-0', 'pointer-events-none');
                        document.getElementById('login-btn')?.classList.remove('hidden');
                        document.getElementById('guest-btn')?.classList.remove('hidden');
                    }, 500);
                }, 800);
            }
        }
        
        // Texture loading with bump and specular maps
        TERMINAL.setStage('stage-texture');
        TERMINAL.log('load', 'Requesting satellite imagery...');
        TERMINAL.setProgress(5);
        
        let texturesLoadedCount = 0;
        const totalTextures = 3;
        
        function onTextureProgress() {
            texturesLoadedCount++;
            TERMINAL.setProgress(5 + (texturesLoadedCount / totalTextures) * 15);
            if (texturesLoadedCount >= totalTextures) {
                TERMINAL.log('ok', 'All globe textures loaded');
                textureLoaded = true;
                checkLoadStatus();
            }
        }
        
        // Main diffuse texture
        textureLoader.load(CONFIG.textureUrl, 
            (t) => { 
                TERMINAL.log('ok', 'Diffuse map loaded');
                t.anisotropy = 4;
                earthMat.map = t; 
                earthMat.needsUpdate = true;
                onTextureProgress();
            },
            undefined,
            (err) => {
                TERMINAL.log('err', 'Diffuse map failed');
                onTextureProgress();
            }
        );
        
        // Bump map for terrain
        textureLoader.load(CONFIG.bumpMapUrl, 
            (t) => { 
                TERMINAL.log('ok', 'Topology map loaded');
                earthMat.bumpMap = t; 
                earthMat.needsUpdate = true;
                onTextureProgress();
            },
            undefined,
            (err) => {
                TERMINAL.log('wait', 'Topology map skipped');
                onTextureProgress();
            }
        );
        
        // Specular map for water reflections
        textureLoader.load(CONFIG.specMapUrl, 
            (t) => { 
                TERMINAL.log('ok', 'Specular map loaded');
                earthMat.specularMap = t; 
                earthMat.needsUpdate = true;
                onTextureProgress();
            },
            undefined,
            (err) => {
                TERMINAL.log('wait', 'Specular map skipped');
                onTextureProgress();
            }
        );
        
        // Fallback timeout for textures
        setTimeout(() => {
            if (!textureLoaded) {
                TERMINAL.log('wait', 'Texture timeout - proceeding');
                textureLoaded = true;
                checkLoadStatus();
            }
        }, 8000);
        
        const earthMesh = new THREE.Mesh(new THREE.SphereGeometry(10, 128, 128), earthMat);
        earthMesh.name = "Earth";
        globeGroup.add(earthMesh);

        // Highlight & Flag Fill Shader - Higher resolution for crisp flags
        // Create a higher resolution canvas for the active country flag.  The
        // original size (2048√ó1024) produced noticeable pixelation when
        // stretching flags over large countries.  Doubling the resolution
        // yields crisper details.  Note: this texture is only used for the
        // currently highlighted country, so memory impact is minimal.
        STATE.flagCanvas = document.createElement('canvas');
        // Increase atlas resolution for crisper flags.  Use a very large atlas to avoid blending
        // between neighbouring flags.  The atlas is now 8192x4096 which allows generous margins
        // between country textures.  Note: extremely large textures can increase GPU memory
        // usage but improves clarity on modern devices.  If performance suffers this can
        // be reduced to 4096x2048.
        STATE.flagCanvas.width = 8192;
        STATE.flagCanvas.height = 4096;
        STATE.flagCtx = STATE.flagCanvas.getContext('2d');
        STATE.flagTexture = new THREE.CanvasTexture(STATE.flagCanvas);
        // Use linear filtering for smooth scaling of the flag; anisotropy
        // improves texture quality at oblique angles.
        STATE.flagTexture.minFilter = THREE.LinearFilter;
        STATE.flagTexture.magFilter = THREE.LinearFilter;
        STATE.flagTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

        // Preload a global flag map texture for sampling flags directly from a
        // world map.  This high resolution image is stored alongside the
        // application under the name `world_flag_map.jpg`.  When loaded
        // successfully it will be assigned to highlightMaterial.tGlobalFlagMap
        // and enable useGlobalFlagMap so that the fragment shader samples
        // colours directly from this equirectangular image instead of the
        // per‚Äëcountry canvas.  This avoids stretching and scaling artifacts
        // when switching between countries.
        const globalFlagLoader = new THREE.TextureLoader();
        globalFlagLoader.load('world_flag_map.jpg', (tex) => {
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
          tex.needsUpdate = true;
          STATE.globalFlagTexture = tex;
          // If the highlight material has been created, assign the texture.  We do
          // not enable useGlobalFlagMap by default; that must be toggled via settings.
          if (highlightMaterial) {
            highlightMaterial.uniforms.tGlobalFlagMap.value = tex;
          }
        }, undefined, (err) => {
          console.warn('Failed to load global flag map:', err);
        });

        /* ============================================
           5. GLOBE & SHADER SYSTEM
           ============================================ */
        let highlightMaterial;
        function createHighlightSphere() {
            STATE.statusTexture = new THREE.DataTexture(STATE.statusData, 256, 1, THREE.RedFormat, THREE.UnsignedByteType);
            STATE.statusTexture.minFilter = THREE.NearestFilter; STATE.statusTexture.magFilter = THREE.NearestFilter; STATE.statusTexture.needsUpdate = true;
            
            // Initialize the flag render system
            FLAG_RENDER.init(renderer);

            highlightMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tLookup: { value: null },
                    tStatus: { value: STATE.statusTexture },
                    tFlag: { value: STATE.flagTexture },
                    tFlagAtlas: { value: FLAG_RENDER.texture }, // Accumulated flags
                    uFlagBounds: { value: new THREE.Vector4(0, 0, 1, 1) },
                    uTargetId: { value: -1.0 },
                    uColor: { value: new THREE.Color(0x38bdf8) },
                    uTime: { value: 0 },
                    uFail: { value: 0.0 },
                    uShowFlag: { value: 0.0 },
                    uCountryAspect: { value: 1.0 },
                    uFlagAspect: { value: 1.0 },
                    // Use the global flag map by default if available.  When this
                    // value is 1.0 the shader samples tGlobalFlagMap for both
                    // active and found countries instead of using the per‚Äëcountry
                    // atlas.  This greatly improves flag quality and prevents
                    // scaling artefacts.  The value can be toggled via settings
                    // if future adjustments are desired.
                    useGlobalFlagMap: { value: 1.0 },
                    // Optional global flag map (equirectangular).  This is loaded at runtime
                    // and assigned when ready.  When not null and
                    // useGlobalFlagMap > 0.5 the shader samples this texture.
                    tGlobalFlagMap: { value: null }
                },
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: `
                    uniform sampler2D tLookup; 
                    uniform sampler2D tStatus; 
                    uniform sampler2D tFlag;
                    uniform sampler2D tFlagAtlas;
                    uniform vec4 uFlagBounds;
                    uniform float uTargetId; 
                    uniform vec3 uColor; 
                    uniform float uTime; 
                    uniform float uFail; 
                    uniform float uShowFlag;
                    uniform float uCountryAspect;
                    uniform float uFlagAspect;
                    varying vec2 vUv;

                    uniform float useGlobalFlagMap;
                    uniform sampler2D tGlobalFlagMap;
                    
                    void main() {
                        vec4 texData = texture2D(tLookup, vUv);
                        float id = floor(texData.r * 255.0 + 0.5);
                        float isMain = texData.g;
                        
                        if (id < 0.5) discard; 
                        
                        float lookupU = (id + 0.5) / 256.0;
                        float status = texture2D(tStatus, vec2(lookupU, 0.5)).r;
                        bool isActive = (abs(id - uTargetId) < 0.5 && uTargetId > -0.5);
                        bool isFound = status > 0.9;
                        
                        float pulse = 0.35 + 0.15 * sin(uTime * 3.0);

                        // ACTIVE country with flag (current target)
                        if (isActive && uShowFlag > 0.5 && isMain > 0.5) {
                            // When a global flag map is enabled, sample the map directly
                            // at vUv.  This avoids any scaling or rotation for the flag
                            // overlay and ensures crisp borders.  Glow is computed via
                            // the bounding box to provide subtle emphasis at edges.
                            if (useGlobalFlagMap > 0.5) {
                                vec4 flagColor = texture2D(tGlobalFlagMap, vUv);
                                vec2 localUV2 = (vUv - uFlagBounds.xy) / uFlagBounds.zw;
                                float distFromCenter2 = length(localUV2 - 0.5) * 2.0;
                                float edgeGlow2 = smoothstep(0.3, 1.0, distFromCenter2) * pulse;
                                vec3 highlightTint2 = uFail > 0.5 ? vec3(1.0, 0.2, 0.2) : uColor;
                                vec3 finalColor2 = flagColor.rgb + highlightTint2 * edgeGlow2 * 0.5;
                                gl_FragColor = vec4(finalColor2, 0.95);
                                return;
                            }
                            // Fall back to per‚Äëcountry flag canvas if no global map is available
                            vec2 localUV = (vUv - uFlagBounds.xy) / uFlagBounds.zw;
                            if (localUV.x >= 0.0 && localUV.x <= 1.0 && localUV.y >= 0.0 && localUV.y <= 1.0) {
                                // COVER scaling - flag fills entire country
                                vec2 scale;
                                if (uCountryAspect > uFlagAspect) {
                                    scale = vec2(1.0, uFlagAspect / uCountryAspect);
                                } else {
                                    scale = vec2(uCountryAspect / uFlagAspect, 1.0);
                                }
                                vec2 flagUV = (localUV - 0.5) * scale + 0.5;
                                if (flagUV.x >= 0.0 && flagUV.x <= 1.0 && flagUV.y >= 0.0 && flagUV.y <= 1.0) {
                                    vec4 flagColor = texture2D(tFlag, flagUV);
                                    float distFromCenter = length(localUV - 0.5) * 2.0;
                                    float edgeGlow = smoothstep(0.3, 1.0, distFromCenter) * pulse;
                                    vec3 highlightTint = uFail > 0.5 ? vec3(1.0, 0.2, 0.2) : uColor;
                                    vec3 finalColor = flagColor.rgb + highlightTint * edgeGlow * 0.5;
                                    gl_FragColor = vec4(finalColor, 0.95);
                                    return;
                                }
                            }
                        }

                        // FOUND countries - show flags.  When using the global map, sample
                        // directly from tGlobalFlagMap instead of the atlas.  This ensures
                        // that persistent flags remain crisp and consistent across
                        // selections.  If no global map is available, fall back to the
                        // accumulated atlas texture.
                        if (isFound && isMain > 0.5) {
                            if (useGlobalFlagMap > 0.5) {
                                vec4 flagColor = texture2D(tGlobalFlagMap, vUv);
                                gl_FragColor = vec4(flagColor.rgb, 0.85);
                                return;
                            } else {
                                vec4 atlasColor = texture2D(tFlagAtlas, vUv);
                                if (atlasColor.a > 0.1 || (atlasColor.r + atlasColor.g + atlasColor.b) > 0.05) {
                                    gl_FragColor = vec4(atlasColor.rgb, 0.85);
                                    return;
                                }
                                gl_FragColor = vec4(0.13, 0.77, 0.37, 0.4);
                                return;
                            }
                        }

                        // Active highlight (no flag shown yet)
                        if (isActive) {
                            gl_FragColor = vec4(uFail > 0.5 ? vec3(1.0, 0.0, 0.0) : uColor, pulse);
                        }
                        // Found (green)
                        else if (isFound) {
                            gl_FragColor = vec4(0.13, 0.77, 0.37, 0.4);
                        }
                        // Skipped (red)
                        else if (status > 0.4 && status < 0.6) {
                            gl_FragColor = vec4(0.93, 0.26, 0.26, 0.4);
                        }
                        else {
                            discard;
                        }
                    }
                `,
                transparent: true, side: THREE.FrontSide
            });

            // If a global flag texture has already been loaded before the
            // highlight material was created, assign it now.  This ensures
            // the shader can immediately sample the world map without
            // waiting for the asynchronous loader callback.
            if (STATE.globalFlagTexture) {
                highlightMaterial.uniforms.tGlobalFlagMap.value = STATE.globalFlagTexture;
            }

            // If a global flag texture has already been loaded before this
            // material was created, assign it now and enable the global map
            // flag.  Without this check the global map would only be set
            // inside the texture loader callback, which might run before or
            // after shader creation.
            if (STATE.globalFlagTexture) {
                // Assign the global flag texture if it has been loaded.  Note: we do not
                // automatically enable useGlobalFlagMap here.  It remains disabled
                // by default until explicitly turned on via user settings.
                highlightMaterial.uniforms.tGlobalFlagMap.value = STATE.globalFlagTexture;
            }
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(10.02, 128, 128), highlightMaterial);
            mesh.name = "Highlight";
            globeGroup.add(mesh);
            console.log('Highlight sphere created');
        }
        try {
            createHighlightSphere();
        } catch(e) {
            console.error('createHighlightSphere error:', e);
        }

        const atmoMat = new THREE.ShaderMaterial({
            uniforms: { color: { value: new THREE.Color(0x38bdf8) }, uFail: { value: 0.0 } },
            vertexShader: `varying vec3 vNormal; void main() { vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `uniform vec3 color; uniform float uFail; varying vec3 vNormal; void main() { float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 6.0); gl_FragColor = vec4(uFail > 0.5 ? vec3(1.0, 0.0, 0.0) : color, 1.0) * intensity * 0.8; }`,
            blending: THREE.AdditiveBlending, side: THREE.BackSide, transparent: true
        });
        {
            const atmoMesh = new THREE.Mesh(new THREE.SphereGeometry(10.3, 64, 64), atmoMat);
            atmoMesh.name = 'Atmosphere';
            globeGroup.add(atmoMesh);
            // Store reference on STATE for toggling via settings
            STATE.atmoMesh = atmoMesh;
        }

        // Create decorative rings (equator and prime meridian) and pole markers on the globe for better orientation
        (function() {
            const ringGroup = new THREE.Group();
            ringGroup.name = 'DecorativeRings';
            // Equator ring
            const equatorGeom = new THREE.TorusGeometry(10.02, 0.01, 16, 128);
            const meridianGeom = new THREE.TorusGeometry(10.02, 0.01, 16, 128);
            meridianGeom.rotateX(Math.PI / 2);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.4, transparent: true });
            const equatorMesh = new THREE.Mesh(equatorGeom, ringMat);
            const meridianMesh = new THREE.Mesh(meridianGeom, ringMat);
            ringGroup.add(equatorMesh);
            ringGroup.add(meridianMesh);
            // Pole markers: small spheres at north and south pole
            const poleGeom = new THREE.SphereGeometry(0.08, 16, 16);
            const poleMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const northPole = new THREE.Mesh(poleGeom, poleMat);
            northPole.position.set(0, 10.02, 0);
            const southPole = new THREE.Mesh(poleGeom, poleMat);
            southPole.position.set(0, -10.02, 0);
            // True north arrow: a small cone pointing upward at north pole
            const arrowGeom = new THREE.ConeGeometry(0.12, 0.4, 16);
            const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const northArrow = new THREE.Mesh(arrowGeom, arrowMat);
            northArrow.position.set(0, 10.45, 0);
            northArrow.rotation.x = Math.PI;
            ringGroup.add(northPole);
            ringGroup.add(southPole);
            ringGroup.add(northArrow);
            globeGroup.add(ringGroup);
            // Make ring group part of STATE so visibility can be toggled later if needed
            STATE.decorativeRings = ringGroup;
        })();

        // Simple sound effects using Web Audio API. Plays short tones for select, correct and wrong actions.
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            // If audio context is suspended (browser policy), resume on user interaction
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            let freq = 600;
            switch(type) {
                case 'select': freq = 800; break;
                case 'correct': freq = 1200; break;
                case 'wrong': freq = 400; break;
                default: freq = 600; break;
            }
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
            // Gradual fade out
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.15);
        }

        // ============================================
        // CONFETTI CELEBRATION SYSTEM
        // ============================================
        const Confetti = {
            canvas: null,
            ctx: null,
            particles: [],
            animating: false,

            init() {
                this.canvas = document.getElementById('confetti-canvas');
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
            },

            resize() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            },

            // DRAMATIC burst with multiple waves
            burst(x, y) {
                const colors = ['#22c55e', '#38bdf8', '#fbbf24', '#f472b6', '#a855f7', '#ef4444', '#ffffff'];

                // 3 waves of 50 particles each = 150 total
                for (let wave = 0; wave < 3; wave++) {
                    setTimeout(() => {
                        for (let i = 0; i < 50; i++) {
                            const angle = (Math.PI * 2 / 50) * i + Math.random() * 0.5;
                            const velocity = 8 + Math.random() * 12;
                            this.particles.push({
                                x: x + (Math.random() - 0.5) * 100,
                                y: y + (Math.random() - 0.5) * 50,
                                vx: Math.cos(angle) * velocity,
                                vy: Math.sin(angle) * velocity - 10,
                                size: Math.random() * 12 + 6,
                                color: colors[Math.floor(Math.random() * colors.length)],
                                rotation: Math.random() * 360,
                                rotationSpeed: (Math.random() - 0.5) * 15,
                                life: 1,
                                gravity: 0.3,
                                drag: 0.98,
                                shape: Math.random() > 0.5 ? 'rect' : 'circle'
                            });
                        }
                    }, wave * 100);
                }

                if (!this.animating) this.animate();
            },

            animate() {
                if (!this.ctx) return;
                this.animating = true;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += p.gravity;
                    p.vx *= p.drag;
                    p.rotation += p.rotationSpeed;
                    p.life -= 0.015;

                    if (p.life > 0) {
                        this.ctx.save();
                        this.ctx.translate(p.x, p.y);
                        this.ctx.rotate(p.rotation * Math.PI / 180);
                        this.ctx.globalAlpha = p.life;
                        this.ctx.fillStyle = p.color;

                        if (p.shape === 'rect') {
                            this.ctx.fillRect(-p.size/2, -p.size/4, p.size, p.size/2);
                        } else {
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, p.size/2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }

                        this.ctx.restore();
                        return true;
                    }
                    return false;
                });

                if (this.particles.length > 0) {
                    requestAnimationFrame(() => this.animate());
                } else {
                    this.animating = false;
                }
            }
        };

        // Show celebratory overlay for correct answers
        function showCorrectOverlay() {
            const overlay = document.createElement('div');
            overlay.className = 'correct-overlay';
            overlay.innerHTML = `
                <div class="correct-text">CORRECT!</div>
                <div class="correct-icon">‚úì</div>
            `;
            document.body.appendChild(overlay);

            // Trigger confetti burst from center-top of screen
            Confetti.burst(window.innerWidth / 2, window.innerHeight / 3);

            setTimeout(() => {
                overlay.classList.add('fade-out');
                setTimeout(() => overlay.remove(), 500);
            }, 800);
        }

        const graticuleGroup = new THREE.Group(); globeGroup.add(graticuleGroup);

        /**
         * High-resolution globe texture sources for different themes.
         * Using CDN URLs for consistent quality across all users.
         */
        const GLOBE_TEXTURES = {
            // High-res NASA Blue Marble (default)
            blueMarble: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-blue-marble.jpg',
            // Night lights (city lights)
            night: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-night.jpg',
            // Dark/grayscale map
            dark: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-dark.jpg',
            // Topology map with elevation colors
            topology: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-topology.png',
            // Water map (ocean mask)
            water: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-water.png',
            // Local fallbacks (if CDN fails)
            localDay: 'earth_daymap_2k.jpg',
            localNight: 'earth_nightmap_2k.jpg',
            localGray: 'earth_daymap_gray.jpg'
        };

        /**
         * Preload high resolution earth textures for different themes.
         * Loads from CDN with local fallbacks for offline support.
         */
        async function preloadEarthTextures() {
            const loader = new THREE.TextureLoader();

            // Configure texture after loading
            const configureTexture = (tex) => {
                if (tex) {
                    tex.flipY = false;
                    tex.encoding = THREE.sRGBEncoding;
                    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                }
                return tex;
            };

            // Load with fallback
            const loadWithFallback = async (primary, fallback) => {
                let tex = await loader.loadAsync(primary).catch(() => null);
                if (!tex && fallback) {
                    tex = await loader.loadAsync(fallback).catch(() => null);
                }
                return configureTexture(tex);
            };

            // Load all textures in parallel
            const [blueMarble, night, dark, topology] = await Promise.all([
                loadWithFallback(GLOBE_TEXTURES.blueMarble, GLOBE_TEXTURES.localDay),
                loadWithFallback(GLOBE_TEXTURES.night, GLOBE_TEXTURES.localNight),
                loadWithFallback(GLOBE_TEXTURES.dark, GLOBE_TEXTURES.localGray),
                loadWithFallback(GLOBE_TEXTURES.topology, null)
            ]);

            STATE.earthTextures = {
                day: blueMarble,
                night: night,
                gray: dark,
                topology: topology,
                // Alias for themes
                blueMarble: blueMarble,
                dark: dark
            };

            console.log('Earth textures loaded:', Object.keys(STATE.earthTextures).filter(k => STATE.earthTextures[k]).join(', '));
        }

        function setTheme(theme) {
            document.body.className = `theme-${theme}`;
            const computed = getComputedStyle(document.body);
            const accent = computed.getPropertyValue('--accent-color').trim();
            const bg = computed.getPropertyValue('--bg-color').trim();
            atmoMat.uniforms.color.value.set(accent);
            highlightMaterial.uniforms.uColor.value.set(accent);
            scene.fog = new THREE.FogExp2(bg, 0.02);

            // Theme-specific globe texture mapping:
            // - cyber/navy: Blue Marble (vibrant satellite view)
            // - royal: Blue Marble (rich colors match gold accents)
            // - terminal: Night map (city lights on dark background)
            // - midnight: Night map (purple glow with city lights)
            // - paper: Dark/Gray map (cartographer style)
            let tex = null;
            if (STATE.earthTextures) {
                switch (theme) {
                    case 'terminal':
                        // Green terminal theme - night map with city lights
                        tex = STATE.earthTextures.night || STATE.earthTextures.dark || STATE.earthTextures.day;
                        break;
                    case 'midnight':
                        // Purple midnight theme - night city lights
                        tex = STATE.earthTextures.night || STATE.earthTextures.day;
                        break;
                    case 'paper':
                    case 'cartographer':
                        // Paper/vintage theme - grayscale/dark map
                        tex = STATE.earthTextures.dark || STATE.earthTextures.gray || STATE.earthTextures.day;
                        break;
                    case 'royal':
                        // Royal gold theme - topology map shows terrain elevation
                        tex = STATE.earthTextures.topology || STATE.earthTextures.day;
                        break;
                    case 'cyber':
                    case 'navy':
                    default:
                        // Default: Blue Marble HD
                        tex = STATE.earthTextures.blueMarble || STATE.earthTextures.day;
                        break;
                }
            }
            if (tex && STATE.earthMaterial) {
                STATE.earthMaterial.map = tex;
                STATE.earthMaterial.needsUpdate = true;
            }

            // Update graticule (grid) color to match theme
            updateGraticuleColor();

            // Store current theme for reference
            STATE.currentTheme = theme;
        }

        // --- DATA ---

        async function loadData() {
            TERMINAL.setStage('stage-geo');

            // Preload high resolution earth textures used for different themes.
            // This runs in parallel with other asset loading to avoid delays
            // during theme switches.  If textures fail to load they are
            // gracefully skipped and the existing diffuse texture will be used.
            try {
                await preloadEarthTextures();
            } catch (e) {
                console.warn('Error preloading earth textures:', e);
            }
            TERMINAL.log('load', 'Fetching geopolitical boundaries...');
            TERMINAL.setProgress(30);
            
            try {
                const res = await fetch(CONFIG.geoJsonUrl);
                if (!res.ok) throw new Error('GeoJSON fetch failed: ' + res.status);
                TERMINAL.log('ok', 'GeoJSON response received');
                TERMINAL.setProgress(40);
                
                const data = await res.json();
                TERMINAL.log('ok', `Parsing ${data.features?.length || 0} territories...`);
                TERMINAL.setProgress(50);
                
                data.features.forEach(f => {
                    if (f.properties.ISO_A2 === '-99') {
                        if (f.properties.NAME === 'France') f.properties.ISO_A2 = 'FR';
                        else if (f.properties.NAME === 'Norway') f.properties.ISO_A2 = 'NO';
                    }
                });

                STATE.countries = data.features.map((f, index) => {
                    // Determine the primary polygon (main landmass) to compute orientation and bounding box.
                    let mainPolyCoords = f.geometry.coordinates;
                    let maxLen = 0;
                    if (f.geometry.type === 'MultiPolygon') {
                        f.geometry.coordinates.forEach(poly => {
                            const len = poly[0].length;
                            if (len > maxLen) { maxLen = len; mainPolyCoords = poly; }
                        });
                    } else {
                        mainPolyCoords = f.geometry.coordinates;
                    }

                    // Compute axis-aligned bounds for the entire geometry.
                    const bounds = f.geometry.type === 'MultiPolygon' ? getPolyBounds(mainPolyCoords[0]) : calculateBounds(f.geometry);
                    const center = [(bounds.minY + bounds.maxY) / 2, (bounds.minX + bounds.maxX) / 2];

                    // Compute orientation of the primary ring for flag alignment.
                    let orientation = 0;
                    try {
                        const ring = Array.isArray(mainPolyCoords[0][0]) ? mainPolyCoords[0] : mainPolyCoords;
                        orientation = computeOrientation(ring);
                    } catch (e) {
                        orientation = 0;
                    }

                    // Determine if this country is considered small (mostly islands or microstates).
                    const lonRange = bounds.maxX - bounds.minX;
                    const latRange = bounds.maxY - bounds.minY;
                    // Mark a country as small only if its bounding box is extremely tiny (less than ~1¬∞ in both directions).
                    // We no longer treat high latitude countries as small automatically; this avoids creating 2D tags for
                    // large northern countries like Canada or Russia. Only microstates and tiny islands should be tagged.
                    const isSmall = (lonRange < 1 && latRange < 1);

                    return {
                        id: index + 1,
                        name: f.properties.NAME,
                        iso: f.properties.ISO_A2,
                        continent: f.properties.CONTINENT,
                        subregion: f.properties.SUBREGION,
                        geometry: f.geometry,
                        center: center,
                        mainPolyCoords: mainPolyCoords,
                        bounds: bounds,
                        orientation: orientation,
                        isSmall: isSmall
                    };
                }).filter(c => c.iso && c.iso !== '-99');
                STATE.countries.sort((a,b) => a.name.localeCompare(b.name));
                TERMINAL.log('ok', `${STATE.countries.length} countries indexed`);
                TERMINAL.setProgress(60);

                // Load a global map of flags (equirectangular). This map is used
                // to display country flags without individually drawing
                // textures for each country.  Once loaded, the highlight
                // shader samples this texture for active highlights via
                // tGlobalFlagMap.  If the texture fails to load, the
                // shader falls back to the per-country flag canvas.
                try {
                    const loader = new THREE.TextureLoader();
                    loader.setCrossOrigin('');
                    loader.load('https://upload.wikimedia.org/wikipedia/commons/8/87/Flag_Map_of_The_World.png', tex => {
                        tex.encoding = THREE.sRGBEncoding;
                        tex.minFilter = THREE.LinearFilter;
                        tex.magFilter = THREE.LinearFilter;
                        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        STATE.globalFlagTexture = tex;
                        if (highlightMaterial && highlightMaterial.uniforms.tGlobalFlagMap) {
                            // Assign the global flag map texture but do not enable
                            // it by default.  We keep useGlobalFlagMap at 0.0 so
                            // that per-country flags are used instead.  If you
                            // wish to sample from the world flag map, set
                            // useGlobalFlagMap to 1.0 manually via settings.
                            highlightMaterial.uniforms.tGlobalFlagMap.value = tex;
                            // Do not enable automatic use of global flag map here.
                            highlightMaterial.uniforms.useGlobalFlagMap.value = 0.0;
                            highlightMaterial.needsUpdate = true;
                        }
                        TERMINAL.log('ok', 'World flag map loaded');
                    }, undefined, err => {
                        console.warn('World flag map failed to load', err);
                    });
                } catch (e) {
                    console.warn('Error loading world flag map:', e);
                }
                
                TERMINAL.setStage('stage-render');
                TERMINAL.log('load', 'Building UI components...');
                populateDropdown();
                await new Promise(r => setTimeout(r, 50)); 
                
                TERMINAL.log('load', 'Generating lookup textures...');
                TERMINAL.setProgress(70);
                generateLookupTexture();
                
                TERMINAL.log('load', 'Rendering political borders...');
                TERMINAL.setProgress(80);
                createBorders();
                
                TERMINAL.log('load', 'Initializing interface...');
                TERMINAL.setProgress(90);
                populateSidebar();
                createGraticule();
                populateQuizMenu();
                
                TERMINAL.log('ok', 'Render pipeline complete');

                geoDataLoaded = true;
                console.log('GeoData processing complete');
                
                // Preload flags in background
                TERMINAL.log('load', 'Caching flag images...');
                FLAG_CACHE.preloadAll(STATE.countries, (loaded, total) => {
                    const pct = Math.round((loaded / total) * 100);
                    if (loaded % 20 === 0 || loaded === total) {
                        TERMINAL.log('load', `Flags cached: ${loaded}/${total}`);
                    }
                }).then(() => {
                    TERMINAL.log('ok', `${FLAG_CACHE.images.size} flags ready`);
                    flagsLoaded = true;
                    checkLoadStatus();
                });
                
                checkLoadStatus();

            } catch (e) { 
                console.error('Load error:', e);
                TERMINAL.log('err', 'Load error: ' + e.message);
                geoDataLoaded = true;
                checkLoadStatus();
            }
        }

        function populateDropdown() {
            const list = document.getElementById('country-dropdown-list');
            if(!list) return;
            list.innerHTML = '';
            STATE.countries.forEach(c => {
                const item = document.createElement('div');
                item.className = 'option-item';
                item.innerHTML = `<img src="https://flagcdn.com/w40/${c.iso.toLowerCase()}.png"><span>${c.name}</span>`;
                item.onclick = () => {
                    document.getElementById('user-country-val').value = c.name;
                    document.getElementById('selected-country-display').innerHTML = item.innerHTML;
                    list.classList.remove('show');
                };
                list.appendChild(item);
            });
        }

        const countrySelectBtn = document.getElementById('country-select-btn');
        if(countrySelectBtn) {
            countrySelectBtn.onclick = (e) => {
                e.stopPropagation(); 
                const list = document.getElementById('country-dropdown-list');
                if(list) list.classList.toggle('show');
            };
        }
        window.addEventListener('click', () => { 
            const list = document.getElementById('country-dropdown-list');
            if(list) list.classList.remove('show'); 
        });

        function getPolyBounds(coords) {
             let minX=180, maxX=-180, minY=90, maxY=-90;
             coords.forEach(c => { if(c[0]<minX)minX=c[0]; if(c[0]>maxX)maxX=c[0]; if(c[1]<minY)minY=c[1]; if(c[1]>maxY)maxY=c[1]; });
             return {minX, maxX, minY, maxY};
        }

        function calculateBounds(geometry) {
            let minX = 180, maxX = -180, minY = 90, maxY = -90;
            const process = (coords) => {
                coords.forEach(c => { if (Array.isArray(c[0])) process(c); else { if (c[0]<minX)minX=c[0]; if(c[0]>maxX)maxX=c[0]; if(c[1]<minY)minY=c[1]; if(c[1]>maxY)maxY=c[1]; }});
            };
            process(geometry.coordinates);
            return { minX, maxX, minY, maxY };
        }

        /**
         * Compute the orientation angle (in radians) of the longest axis of a polygon ring using principal component analysis.
         * The ring should be an array of [lon, lat] coordinates.
         * The returned angle is constrained to the range [-PI/2, PI/2] and represents the direction of the
         * country's longest dimension in the equirectangular projection. This value is later used to orient
         * flag textures along the longest axis of each country.
         */
        function computeOrientation(ring) {
            if (!Array.isArray(ring) || ring.length === 0) return 0;
            let meanX = 0, meanY = 0;
            const pts = ring.filter(pt => Array.isArray(pt) && pt.length >= 2);
            const n = pts.length;
            if (n === 0) return 0;
            pts.forEach(pt => { meanX += pt[0]; meanY += pt[1]; });
            meanX /= n; meanY /= n;
            let xx = 0, xy = 0, yy = 0;
            pts.forEach(pt => {
                const dx = pt[0] - meanX;
                const dy = pt[1] - meanY;
                xx += dx * dx;
                xy += dx * dy;
                yy += dy * dy;
            });
            const trace = xx + yy;
            const det = xx * yy - xy * xy;
            let eigVal = 0;
            if (trace !== 0) {
                const disc = Math.max(0, (trace * trace) / 4 - det);
                eigVal = trace / 2 + Math.sqrt(disc);
            }
            // Eigenvector corresponding to the largest eigenvalue
            let vx = eigVal - yy;
            let vy = xy;
            if (Math.abs(vx) < 1e-6 && Math.abs(vy) < 1e-6) {
                // Fallback to x-axis if covariance is degenerate
                vx = 1; vy = 0;
            }
            let angle = Math.atan2(vy, vx);
            // Normalize angle to [-PI/2, PI/2] so that the orientation is consistent
            if (angle < -Math.PI / 2) angle += Math.PI;
            if (angle > Math.PI / 2) angle -= Math.PI;
            return angle;
        }

        // --- GRAPHICS ---
        function generateLookupTexture() {
            // 4K resolution for good balance of quality and performance
            const texWidth = 4096, texHeight = 2048;
            const canvas = document.createElement('canvas'); 
            canvas.width = texWidth; canvas.height = texHeight;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            STATE.countries.forEach(c => {
                // R Channel = ID
                // G Channel = Main Land Mask (255 if main, 0 if colony)
                
                // 1. Fill all colonies with ID but G=0
                ctx.fillStyle = `rgb(${c.id}, 0, 0)`; 
                drawGeometryToCanvas(ctx, c.geometry, canvas.width, canvas.height);

                // 2. Overwrite main land with G=255
                ctx.fillStyle = `rgb(${c.id}, 255, 0)`;
                let coords = c.geometry.type === 'MultiPolygon' ? c.mainPolyCoords : c.geometry.coordinates;
                const tempGeo = { type: "Polygon", coordinates: coords };
                drawGeometryToCanvas(ctx, tempGeo, canvas.width, canvas.height);
            });
            const tex = new THREE.CanvasTexture(canvas); 
            tex.minFilter = THREE.NearestFilter; 
            tex.magFilter = THREE.NearestFilter;
            highlightMaterial.uniforms.tLookup.value = tex;
            STATE.mapData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            STATE.mapWidth = texWidth;
            STATE.mapHeight = texHeight;
        }

        function drawGeometryToCanvas(ctx, geometry, w, h) {
            const drawPoly = (coords) => {
                ctx.beginPath();
                coords.forEach((pt, i) => {
                    const x = (pt[0] + 180) / 360 * w;
                    const y = (90 - pt[1]) / 180 * h;
                    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                });
                ctx.fill();
            };
            if (geometry.type === 'Polygon') geometry.coordinates.forEach(drawPoly);
            else if (geometry.type === 'MultiPolygon') geometry.coordinates.forEach(poly => poly.forEach(drawPoly));
        }

        // Ocean grid material - will be updated with theme color
        let oceanGridMaterial = null;

        function createGraticule() {
            // Create material with theme-aware color
            const computed = getComputedStyle(document.body);
            const accentColor = computed.getPropertyValue('--accent-color').trim() || '#38bdf8';

            oceanGridMaterial = new THREE.LineBasicMaterial({
                color: new THREE.Color(accentColor),
                transparent: true,
                opacity: 0.2
            });

            // Longitude lines (vertical) - every 15 degrees
            for (let lon = -180; lon < 180; lon += 15) {
                const theta = ((lon + 180) / 360) * Math.PI * 2;
                const pts = [];
                for (let j = 0; j <= 64; j++) {
                    const phi = (j / 64) * Math.PI;
                    pts.push(new THREE.Vector3(
                        10.05 * Math.sin(phi) * Math.cos(theta),
                        10.05 * Math.cos(phi),
                        10.05 * Math.sin(phi) * Math.sin(theta)
                    ));
                }
                graticuleGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), oceanGridMaterial));
            }

            // Latitude lines (horizontal) - every 15 degrees
            for (let lat = -75; lat <= 75; lat += 15) {
                const phi = ((90 - lat) / 180) * Math.PI;
                const r = 10.05 * Math.sin(phi);
                const y = 10.05 * Math.cos(phi);
                const pts = [];
                for (let j = 0; j <= 64; j++) {
                    const theta = (j / 64) * Math.PI * 2;
                    pts.push(new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta)));
                }
                graticuleGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), oceanGridMaterial));
            }

            // Special lines: Equator (thicker/more visible)
            const equatorMat = new THREE.LineBasicMaterial({
                color: new THREE.Color(accentColor),
                transparent: true,
                opacity: 0.4
            });
            const equatorPts = [];
            for (let j = 0; j <= 64; j++) {
                const theta = (j / 64) * Math.PI * 2;
                equatorPts.push(new THREE.Vector3(10.05 * Math.cos(theta), 0, 10.05 * Math.sin(theta)));
            }
            graticuleGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(equatorPts), equatorMat));

            // Prime Meridian (0¬∞ longitude)
            const primeMeridianPts = [];
            for (let j = 0; j <= 64; j++) {
                const phi = (j / 64) * Math.PI;
                primeMeridianPts.push(new THREE.Vector3(10.05 * Math.sin(phi), 10.05 * Math.cos(phi), 0));
            }
            graticuleGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(primeMeridianPts), equatorMat));
        }

        // Update graticule and border colors when theme changes
        function updateGraticuleColor() {
            const computed = getComputedStyle(document.body);
            const accentColor = computed.getPropertyValue('--accent-color').trim() || '#38bdf8';

            // Update graticule (grid)
            if (oceanGridMaterial) {
                oceanGridMaterial.color.set(accentColor);
            }

            // Update country borders
            if (STATE.borderMaterial) {
                STATE.borderMaterial.color.set(accentColor);
            }
            if (STATE.seaBorderMaterial) {
                STATE.seaBorderMaterial.color.set(accentColor);
            }
        }

        function createBorders() {
            STATE.borderGroup = new THREE.Group();
            STATE.borderGroup.name = "Borders";

            // Get theme accent color for borders
            const computed = getComputedStyle(document.body);
            const accentColor = computed.getPropertyValue('--accent-color').trim() || '#38bdf8';

            // Use basic line material with theme-aware color
            // Higher opacity for better visibility
            STATE.borderMaterial = new THREE.LineBasicMaterial({
                color: new THREE.Color(accentColor),
                transparent: true,
                opacity: 0.6
            });

            // Secondary material for small island emphasis (even more visible)
            STATE.seaBorderMaterial = new THREE.LineBasicMaterial({
                color: new THREE.Color(accentColor),
                transparent: true,
                opacity: 0.8
            });
            
            STATE.countries.forEach(country => {
                const isSmall = country.isSmall;
                const processRing = (ring) => {
                    if (ring.length < 2) return;
                    const pts = [];
                    const ptsOuter = [];
                    ring.forEach(coord => {
                        const lon = coord[0], lat = coord[1];
                        const phi = (90 - lat) * Math.PI / 180;
                        const theta = (lon + 180) * Math.PI / 180;
                        // Inner border radius just above globe surface
                        const r = 10.015;
                        pts.push(new THREE.Vector3(
                            -r * Math.sin(phi) * Math.cos(theta),
                            r * Math.cos(phi),
                            r * Math.sin(phi) * Math.sin(theta)
                        ));
                        // Outer sea border slightly further out for small islands
                        if (isSmall) {
                            const rOut = 10.045; // slight offset for sea border
                            ptsOuter.push(new THREE.Vector3(
                                -rOut * Math.sin(phi) * Math.cos(theta),
                                rOut * Math.cos(phi),
                                rOut * Math.sin(phi) * Math.sin(theta)
                            ));
                        }
                    });
                    if (pts.length >= 2) {
                        const geometry = new THREE.BufferGeometry().setFromPoints(pts);
                        const line = new THREE.Line(geometry, STATE.borderMaterial);
                        STATE.borderGroup.add(line);
                    }
                    // Add sea border line for small islands (more visible)
                    if (isSmall && ptsOuter.length >= 2) {
                        const geo2 = new THREE.BufferGeometry().setFromPoints(ptsOuter);
                        const line2 = new THREE.Line(geo2, STATE.seaBorderMaterial);
                        STATE.borderGroup.add(line2);
                    }
                };
                if (country.geometry.type === 'Polygon') {
                    country.geometry.coordinates.forEach(processRing);
                } else if (country.geometry.type === 'MultiPolygon') {
                    country.geometry.coordinates.forEach(poly => poly.forEach(processRing));
                }
            });
            
            globeGroup.add(STATE.borderGroup);
        }

        // --- INTERACTION ---
        function getCountryIdFromUV(uv, expandRadius = 3) {
            if (!STATE.mapData) return 0;
            const x = Math.floor(uv.x * STATE.mapWidth);
            const y = Math.floor((1 - uv.y) * STATE.mapHeight);

            // Helper to get pixel ID at given coordinates
            const getPixelId = (px, py) => {
                // Clamp coordinates to valid range
                px = Math.max(0, Math.min(STATE.mapWidth - 1, px));
                py = Math.max(0, Math.min(STATE.mapHeight - 1, py));
                const idx = (py * STATE.mapWidth + px) * 4;
                return STATE.mapData[idx] || 0;
            };

            // Check center pixel first
            let id = getPixelId(x, y);
            if (id > 0) return id;

            // Expand search radius for small islands
            // Check in expanding squares around the center
            for (let r = 1; r <= expandRadius; r++) {
                // Check pixels in a square pattern at radius r
                for (let dx = -r; dx <= r; dx++) {
                    for (let dy = -r; dy <= r; dy++) {
                        // Only check edge pixels of the square (optimization)
                        if (Math.abs(dx) === r || Math.abs(dy) === r) {
                            id = getPixelId(x + dx, y + dy);
                            if (id > 0) return id;
                        }
                    }
                }
            }
            return 0;
        }

        let dragStartX = 0, dragStartY = 0;
        window.addEventListener('pointerdown', (e) => {
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            if (!STATE.loggedIn) return;
            // Only disable auto-rotation if the pointer is on the globe, not on UI elements.
            const isUiTarget = e.target.closest('#login-modal, #left-panel, #right-panel, #quiz-menu, #game-panel, #hud-bar, #splash-screen, .naked-btn, #country-name-label');
            if (!isUiTarget) {
                controls.autoRotate = false;
            }
        });

        /* ============================================
           8. EVENT HANDLERS
           ============================================ */
        function handleInteraction(e, isClick) {
            if (e.target.closest('#login-modal, #left-panel, #right-panel, #quiz-menu, #game-panel, #hud-bar, #splash-screen, .naked-btn, #country-name-label')) return;
            if (!STATE.loggedIn) return;

            if (isClick) {
                const dist = Math.hypot(e.clientX - dragStartX, e.clientY - dragStartY);
                if (dist > 5) return; 
            }

            const mouse = new THREE.Vector2((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            
            const earthMesh = globeGroup.children.find(c => c.name === "Earth");
            if (!earthMesh) return;
            const intersects = raycaster.intersectObject(earthMesh); 

            if (intersects.length > 0) {
                const id = getCountryIdFromUV(intersects[0].uv);
                if (id > 0) {
                    if (isClick) {
                        const countryObj = STATE.countries.find(c => c.id === id);
                        if (countryObj) {
                                if (STATE.mode === 0) {
                                flyTo(countryObj.center[0], countryObj.center[1], false);
                                highlightMaterial.uniforms.uTargetId.value = id;
                                showFlagOnGlobe(countryObj);
                                    // Play selection sound
                                    playSound('select');
                                // In navigation mode, persist flag on globe and mark country as found for atlas rendering
                                if (STATE.mode === 0) {
                                    // Add to persistent flag atlas
                                    FLAG_RENDER.addFlag(countryObj);
                                    // Mark as found in status data to trigger atlas rendering in shader
                                    if (countryObj.id >= 0 && countryObj.id < STATE.statusData.length) {
                                        STATE.statusData[countryObj.id] = 255;
                                        STATE.statusTexture.needsUpdate = true;
                                    }
                                    // Add to found set for bookkeeping
                                    STATE.found.add(countryObj.id);
                                }
                            } else {
                                const isInteractive = (STATE.mode === 1 || (STATE.mode === 2 && STATE.globalDifficulty === 'hard') || STATE.mode === 4 || STATE.mode === 5 || STATE.mode === 6);
                                if (isInteractive) checkAnswer(countryObj.id);
                            }
                        }
                    } else {
                        document.body.style.cursor = 'pointer';
                        const isInteractive = (STATE.mode === 0 || STATE.mode === 1 || (STATE.mode === 2 && STATE.globalDifficulty === 'hard') || STATE.mode === 4 || STATE.mode === 5 || STATE.mode === 6);
                        
                        if(isInteractive) {
                            if(STATE.mode !== 0 || highlightMaterial.uniforms.uShowFlag.value === 0.0) {
                                 highlightMaterial.uniforms.uTargetId.value = id;
                                 if(STATE.mode !== 0) highlightMaterial.uniforms.uShowFlag.value = 0.0;
                            }
                        }
                    }
                } else {
                    document.body.style.cursor = 'default';
                    if (!isClick && STATE.mode !== 0) highlightMaterial.uniforms.uTargetId.value = -1.0;
                }
            }
        }

        function showFlagOnGlobe(country) {
            // If global map usage is enabled, we draw no individual flag texture.  Instead we
            // simply update the uniforms so the shader knows which country to display.  For
            // small island states we still use a 3D sprite to improve visibility.  When not
            // using the global map, we fall back to drawing the specific country flag
            // onto the flag canvas.
            const useGlobal = highlightMaterial.uniforms.useGlobalFlagMap.value > 0.5;
            // Try cached image first (instant) for non-global case
            const cachedImg = FLAG_CACHE.get(country.iso);

            // Helper to compute bounding box uniforms and update highlight uniforms.  This
            // computes the bounding rectangle in UV space and applies a margin to
            // prevent edge bleeding.  When using the global flag map we also set
            // uCountryAspect and uFlagAspect to 1.0 since the projection and flag
            // image share the same aspect.
            function updateBoundsAndUniforms() {
                const b = country.bounds;
                const minU = (b.minX + 180) / 360;
                const maxU = (b.maxX + 180) / 360;
                const realMinV = (b.minY + 90) / 180;
                const realMaxV = (b.maxY + 90) / 180;
                let countryWidth = maxU - minU;
                let countryHeight = realMaxV - realMinV;
                const countryAspect = countryWidth / countryHeight;
                // Apply margin
                const flagMargin = 0.05;
                const shrinkW = countryWidth * (1.0 - flagMargin);
                const shrinkH = countryHeight * (1.0 - flagMargin);
                const offsetU = (countryWidth - shrinkW) * 0.5;
                const offsetV = (countryHeight - shrinkH) * 0.5;
                const boundsU = minU + offsetU;
                const boundsV = realMinV + offsetV;
                highlightMaterial.uniforms.uFlagBounds.value.set(boundsU, boundsV, shrinkW, shrinkH);
                if (useGlobal) {
                    highlightMaterial.uniforms.uCountryAspect.value = 1.0;
                    highlightMaterial.uniforms.uFlagAspect.value = 1.0;
                } else {
                    highlightMaterial.uniforms.uCountryAspect.value = countryAspect;
                    // uFlagAspect will be updated later in renderFlag()
                }
                highlightMaterial.uniforms.uShowFlag.value = 1.0;
                highlightMaterial.uniforms.uTargetId.value = country.id;
            }

            // If using the global flag map for the overlay
            if (useGlobal) {
                // For extremely small island states we still render a sprite tag and 2D tag
                if (country.isSmall) {
                    // Clear any highlight
                    highlightMaterial.uniforms.uShowFlag.value = 0.0;
                    highlightMaterial.uniforms.uTargetId.value = country.id;
                    createFlagSprite(country, cachedImg || null);
                    createFlagTag(country);
                    if (STATE.mode === 0) {
                        FLAG_RENDER.addFlag(country);
                    }
                    if (STATE.mode === 0) {
                        const label = document.getElementById('country-name-label');
                        const text = document.getElementById('country-name-text');
                        if (label && text) {
                            text.textContent = country.name;
                            label.classList.add('visible');
                        }
                    }
                    return;
                }
                // Otherwise update bounding and uniforms
                updateBoundsAndUniforms();
                // Persist the flag on the atlas if in nav mode to keep track of found countries
                if (STATE.mode === 0) {
                    FLAG_RENDER.addFlag(country);
                }
                if (STATE.mode === 0) {
                    const label = document.getElementById('country-name-label');
                    const text = document.getElementById('country-name-text');
                    if (label && text) {
                        text.textContent = country.name;
                        label.classList.add('visible');
                    }
                }
                return;
            }

            // Fallback: use per‚Äëcountry flag texture drawn on the canvas
            function renderFlag(img) {
                // For very small island states, use a 3D billboard instead of projecting the flag texture on the globe.
                if (country.isSmall) {
                    highlightMaterial.uniforms.uTargetId.value = country.id;
                    highlightMaterial.uniforms.uShowFlag.value = 0.0;
                    createFlagSprite(country, img);
                    createFlagTag(country);
                    if (STATE.mode === 0) {
                        FLAG_RENDER.addFlag(country);
                    }
                    if (STATE.mode === 0) {
                        const label = document.getElementById('country-name-label');
                        const text = document.getElementById('country-name-text');
                        if (label && text) {
                            text.textContent = country.name;
                            label.classList.add('visible');
                        }
                    }
                    return;
                }
                const ctx = STATE.flagCtx;
                const canvasW = STATE.flagCanvas.width;
                const canvasH = STATE.flagCanvas.height;
                ctx.clearRect(0, 0, canvasW, canvasH);
                const imgAspect = img.width / img.height;
                const flagAspect = imgAspect;
                let drawW = canvasW;
                let drawH = canvasH;
                if (imgAspect > 2.0) {
                    drawH = canvasW / imgAspect;
                } else {
                    drawW = canvasH * imgAspect;
                }
                const orientation = country.orientation || 0;
                let rotationAngle = 0;
                const isSquare = Math.abs(flagAspect - 1) < 0.1;
                const boundsRatio = (country.bounds.maxX - country.bounds.minX) / (country.bounds.maxY - country.bounds.minY);
                const elongated = (boundsRatio > 9 || boundsRatio < 1.0 / 9.0);
                if (!isSquare && elongated) {
                    if (flagAspect >= 1.0) rotationAngle = orientation;
                    else rotationAngle = orientation + 3.14159265359 / 2.0;
                }
                ctx.save();
                ctx.translate(canvasW / 2, canvasH / 2);
                ctx.rotate(rotationAngle);
                ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
                ctx.restore();
                STATE.flagTexture.needsUpdate = true;
                const finalFlagAspect = drawW / drawH;
                highlightMaterial.uniforms.uFlagAspect.value = finalFlagAspect;
                if (STATE.mode === 0) {
                    const label = document.getElementById('country-name-label');
                    const text = document.getElementById('country-name-text');
                    if (label && text) {
                        text.textContent = country.name;
                        label.classList.add('visible');
                    }
                }
                updateBoundsAndUniforms();
                // For non-global case, the country aspect is updated in updateBoundsAndUniforms()
                // Create or update a 2D flag tag only for tiny island countries
                if (country.isSmall) {
                    createFlagTag(country);
                }
                if (STATE.mode === 0) {
                    FLAG_RENDER.addFlag(country);
                }
            }

            if (useGlobal) {
                // Already handled above; early return
                return;
            }
            if (cachedImg) {
                renderFlag(cachedImg);
            } else {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = `https://flagcdn.com/w320/${country.iso.toLowerCase()}.png`;
                img.onload = () => renderFlag(img);
            }
        }

        /**
         * Create or retrieve a sprite for small countries. A sprite is a billboard facing the
         * camera that displays the flag texture above the globe surface. Sprites are
         * automatically scaled in the animate loop based on camera distance.
         * @param {Object} country - The country object with center coordinates and id.
         * @param {HTMLImageElement} img - The loaded flag image.
         */
        function createFlagSprite(country, img) {
            if (!STATE.flagSprites) STATE.flagSprites = {};
            const existing = STATE.flagSprites[country.id];
            if (existing) {
                // Ensure sprite is visible if flags are currently enabled
                existing.visible = STATE.showFlags !== false;
                return;
            }
            // Draw the image onto a new canvas to avoid CORS issues
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx2 = canvas.getContext('2d');
            ctx2.drawImage(img, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.needsUpdate = true;
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(material);
            sprite.name = `FlagSprite-${country.iso}`;
            sprite.userData.flagAspect = img.width / img.height;
            // Compute 3D position just above the globe surface
            const lat = country.center[0];
            const lon = country.center[1];
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lon + 180) * Math.PI / 180;
            const r = 10.05; // slightly above the globe surface
            sprite.position.set(
                -r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            );
            // Initial scale will be updated in animate loop
            const baseSize = 0.7;
            sprite.scale.set(baseSize, baseSize / sprite.userData.flagAspect, 1);
            sprite.visible = STATE.showFlags !== false;
            STATE.flagSprites[country.id] = sprite;
            globeGroup.add(sprite);
        }

        function checkAnswer(id) {
            if (STATE.mode === 0) return;
            
            if (STATE.globalTimeLimit > 0 && STATE.questionStartTime > 0) {
                if (Date.now() - STATE.questionStartTime > STATE.globalTimeLimit * 1000) return;
            }

            if (STATE.mode === 6) {
                if(STATE.found.has(id)) { showFeedback(null, 'DUPLICATE', 0); return; }
                success(id); document.getElementById('answer-input').value = ''; return;
            }
            if (id === STATE.targetIndex) {
                success(id);
                if(STATE.mode === 2 && STATE.globalDifficulty === 'hard') {
                    const inputArea = document.getElementById('input-area');
                    inputArea.classList.remove('hidden');
                    document.getElementById('type-form').classList.remove('hidden');
                    document.getElementById('answer-input').focus();
                } 
                else if(STATE.mode === 4) {
                    document.getElementById('main-question').textContent = STATE.countries.find(x=>x.id===id).name;
                    setTimeout(nextRound, 1500);
                }
                else if (STATE.mode !== 2 && STATE.mode !== 3) { 
                    // For non-MCQ modes, auto advance
                    setTimeout(nextRound, 1500);
                }
                else if (STATE.mode === 2 || STATE.mode === 3) {
                    // For MCQ modes (easy identify, flag match), advance after showing feedback
                    setTimeout(nextRound, 1500);
                }
            } else if (STATE.mode !== 2 && STATE.mode !== 3) {
                // Only call failEffect for non-MCQ modes (MCQ handles its own)
                failEffect();
            }
        }

        function failEffect() {
            highlightMaterial.uniforms.uFail.value = 1.0;
            atmoMat.uniforms.uFail.value = 1.0;
            setTimeout(() => { highlightMaterial.uniforms.uFail.value = 0.0; atmoMat.uniforms.uFail.value = 0.0; }, 500);
            showFeedback('fail', 'NEGATIVE', 0);
            STATE.score = Math.max(0, STATE.score - 50);
            STATE.falseGuesses++;
            updateHUD();
            if (STATE.falseGuesses >= STATE.maxLives) gameOver();
            playSound('wrong');

            // Add shake animation to game panel
            const gamePanel = document.getElementById('game-panel');
            if (gamePanel) {
                gamePanel.classList.add('shake');
                setTimeout(() => gamePanel.classList.remove('shake'), 400);
            }
        }

        function success(id) {
            const c = STATE.countries.find(c => c.id === id);
            STATE.score += 100;
            STATE.correctCount++;
            STATE.statusData[id] = 255; STATE.statusTexture.needsUpdate = true;
            STATE.found.add(id);

            // Add score animation
            const scoreDisplay = document.getElementById('score-display');
            if (scoreDisplay) {
                scoreDisplay.classList.add('score-animate');
                setTimeout(() => scoreDisplay.classList.remove('score-animate'), 300);
            }
            
            // Add flag to persistent atlas
            FLAG_RENDER.addFlag(c);
            
            // Show current flag on globe
            showFlagOnGlobe(c);
            
            // Visual success feedback - feedback text (hidden during overlay)
            const feedback = document.getElementById('feedback');
            feedback.textContent = "";
            feedback.classList.remove('feedback-success');

            // DRAMATIC celebration overlay with confetti
            showCorrectOverlay();

            updateHUD();
            if(STATE.mode === 6) flyTo(c.center[0], c.center[1], true);
            else if(STATE.globalDifficulty !== 'hard' || STATE.mode === 1) flyTo(c.center[0], c.center[1], false);
            const item = document.getElementById(`country-${id}`);
            if(item) { item.classList.add('found-correct'); item.scrollIntoView({ behavior: 'smooth', block: 'center' }); }

            // Play correct answer sound
            playSound('correct');
        }

        /* ============================================
           6. QUIZ ENGINE
           ============================================ */
        function nextRound() {
            STATE.totalQuestions++;

            // Use quiz pool if available, otherwise fall back to all countries
            const questionPool = STATE.quizPool.length > 0 ? STATE.quizPool : STATE.countries;
            const poolSize = questionPool.length;

            console.log(`nextRound: Pool size=${poolSize}, Found=${STATE.found.size}, Using ${STATE.quizPool.length > 0 ? 'quizPool' : 'all countries'}`);

            // Victory condition: completed all questions in the pool
            if (STATE.found.size >= poolSize && poolSize > 0) {
                console.log('Victory! All questions completed.');
                document.getElementById('final-score').textContent = STATE.score;
                document.getElementById('victory-modal').classList.remove('hidden');
                document.getElementById('game-panel').classList.add('opacity-0', 'translate-y-40');
                // Record stats
                STATS.record(STATE.mode, STATE.score, STATE.correctCount, STATE.totalQuestions, Date.now() - STATE.gameStartTime);
                return;
            }

            // Filter from quiz pool (not all countries)
            let available = questionPool.filter(c => !STATE.found.has(c.id));
            console.log(`Available countries: ${available.length}`);

            if (available.length === 0) {
                // All pool questions answered - show victory
                console.log('Victory! No more available countries.');
                document.getElementById('final-score').textContent = STATE.score;
                document.getElementById('victory-modal').classList.remove('hidden');
                document.getElementById('game-panel').classList.add('opacity-0', 'translate-y-40');
                STATS.record(STATE.mode, STATE.score, STATE.correctCount, STATE.totalQuestions, Date.now() - STATE.gameStartTime);
                return;
            }
            const target = available[Math.floor(Math.random() * available.length)];
            console.log(`Selected target: ${target.name} (${getCountryRegion(target)})`);
            STATE.targetIndex = target.id;
            highlightMaterial.uniforms.uTargetId.value = -1.0;
            setupUI(target);
            
            // Timer Reset
            const pauseBtn = document.getElementById('pause-btn');
            if (STATE.globalTimeLimit > 0) {
                STATE.questionStartTime = Date.now();
                pauseBtn?.classList.remove('hidden');
                startQuestionTimer();
            } else {
                pauseBtn?.classList.add('hidden');
                if(STATE.timerInterval) clearInterval(STATE.timerInterval);
            }
        }

        function setupUI(target) {
            const flagUrl = `https://flagcdn.com/w160/${target.iso.toLowerCase()}.png`;
            const els = { flag: document.getElementById('flag-display'), img: document.getElementById('flag-img'), main: document.getElementById('main-question'), sub: document.getElementById('sub-question'), type: document.getElementById('type-form'), mcq: document.getElementById('mcq-grid'), feedback: document.getElementById('feedback'), input: document.getElementById('answer-input'), skip: document.getElementById('skip-btn') };
            els.flag.classList.add('hidden'); els.type.classList.add('hidden'); els.mcq.classList.add('hidden'); els.mcq.innerHTML = ''; els.feedback.textContent = ''; els.input.value = ''; els.skip.classList.remove('hidden');
            const diff = STATE.globalDifficulty;
            if (STATE.mode !== 1 && STATE.mode !== 3) els.type.classList.remove('hidden');
            
            if (STATE.mode === 1) { // Locate
                 els.flag.classList.remove('hidden'); els.img.src = flagUrl; els.main.textContent = target.name; els.sub.textContent = "LOCATE SECTOR"; 
                 if(diff === 'easy') flyTo(target.center[0], target.center[1], false); 
            }
            else if (STATE.mode === 2) { // Identify
                els.main.textContent = "IDENTIFY NATION";
                if(diff === 'easy') { 
                    els.flag.classList.remove('hidden'); els.img.src = flagUrl; 
                    flyTo(target.center[0], target.center[1], false); 
                    generateMCQ(target, 'name'); 
                } 
                else if(diff === 'medium') { 
                    flyTo(target.center[0], target.center[1], false); 
                    els.type.classList.remove('hidden'); // Text Input
                } 
                else if(diff === 'hard') {
                    // Hard: Show Flag, User clicks Globe, Then types name
                    els.flag.classList.remove('hidden'); els.img.src = flagUrl;
                    els.type.classList.add('hidden'); // Hide input initially
                }
            }
            else if (STATE.mode === 3) { // Flag Match
                els.main.textContent = target.name; 
                if(diff === 'easy' || diff === 'medium') flyTo(target.center[0], target.center[1], false); 
                generateMCQ(target, 'flag'); 
            }
            else if (STATE.mode === 4) { // Rev Locate
                els.flag.classList.remove('hidden'); els.img.src = flagUrl; 
                els.main.textContent = diff === 'easy' ? target.name : "UNKNOWN ORIGIN"; 
                if (diff === 'easy') flyTo(target.center[0], target.center[1], false); 
            }
            else if (STATE.mode === 5) { // Master
                flyTo(target.center[0], target.center[1]); els.main.textContent = "CLASSIFIED"; els.input.focus(); 
            }
            else if (STATE.mode === 6) { // Marathon
                els.main.textContent = "GLOBAL SCAN"; els.input.focus(); els.skip.classList.add('hidden'); 
            }
        }

        function generateMCQ(target, type) {
            const grid = document.getElementById('mcq-grid'); 
            grid.innerHTML = ''; // Clear previous
            grid.classList.remove('hidden');
            
            let opts = [target];
            while(opts.length < 4) { 
                const r = STATE.countries[Math.floor(Math.random() * STATE.countries.length)]; 
                if(!opts.includes(r)) opts.push(r); 
            }
            opts.sort(() => Math.random() - 0.5);
            
            opts.forEach(opt => {
                const btn = document.createElement('button'); 
                btn.className = "mcq-btn w-full py-4 rounded-xl font-bold text-sm transition-all";
                btn.dataset.countryId = opt.id;
                
                if(type === 'name') {
                    btn.textContent = opt.name;
                } else { 
                    btn.classList.add('mcq-flag-only'); 
                    const img = document.createElement('img');
                    
                    // Use cached flag if available
                    const cachedImg = FLAG_CACHE.get(opt.iso);
                    if (cachedImg) {
                        img.src = cachedImg.src;
                    } else {
                        img.src = `https://flagcdn.com/w320/${opt.iso.toLowerCase()}.png`;
                    }
                    img.className = "h-12 mx-auto pointer-events-none"; 
                    btn.appendChild(img); 
                }
                
                btn.onclick = () => {
                    // Disable all buttons
                    grid.querySelectorAll('button').forEach(b => b.disabled = true);
                    
                    if (opt.id === target.id) {
                        btn.classList.add('mcq-correct');
                        checkAnswer(opt.id);
                    } else {
                        btn.classList.add('mcq-wrong');
                        // Highlight correct answer
                        grid.querySelectorAll('button').forEach(b => {
                            if (parseInt(b.dataset.countryId) === target.id) {
                                b.classList.add('mcq-correct');
                            }
                        });
                        failEffect();
                        if (STATE.falseGuesses < STATE.maxLives) {
                            setTimeout(nextRound, 2000);
                        }
                    }
                }; 
                grid.appendChild(btn);
            });
        }

        function flyTo(lat, lon, bounce) {
            // Increment a token for each fly operation.  This allows
            // cancellation of previous fly animations when multiple
            // countries are selected rapidly.  Each animation captures
            // the current token; if a new fly starts, the token is
            // increased and older animations self-terminate.
            if (STATE.flyToken === undefined) STATE.flyToken = 0;
            STATE.flyToken++;
            const token = STATE.flyToken;
            STATE.isFlying = true;
            const phi = (90 - lat) * (Math.PI / 180), theta = (lon + 180) * (Math.PI / 180);
            const targetPos = new THREE.Vector3(-(20 * Math.sin(phi) * Math.cos(theta)), 20 * Math.cos(phi), 20 * Math.sin(phi) * Math.sin(theta));
            const startPos = camera.position.clone();
            const startTime = Date.now();
            function anim() {
                // Abort if a newer fly command has started
                if (token !== STATE.flyToken) return;
                if(!STATE.isFlying) return;
                const now = Date.now(), p = Math.min((now - startTime) / 1000, 1), ease = 1 - Math.pow(1 - p, 3);
                camera.position.lerpVectors(startPos, targetPos, ease);
                camera.lookAt(0,0,0);
                if(p < 1) requestAnimationFrame(anim);
                else { STATE.isFlying = false; if(bounce) { } }
            }
            anim();
        }

        function resetView() {
            // Increment token to cancel any ongoing fly animations
            if (STATE.flyToken === undefined) STATE.flyToken = 0;
            STATE.flyToken++;
            const token = STATE.flyToken;
            STATE.isFlying = true;
            const targetPos = new THREE.Vector3(0, 10, 25);
            const startPos = camera.position.clone();
            const startTime = Date.now();
            
            controls.autoRotate = true;
            updateSlider('nav-autorotate', 0.5);

            function anim() {
                if (token !== STATE.flyToken) return;
                if(!STATE.isFlying) return;
                const p = Math.min((Date.now() - startTime) / 1000, 1);
                camera.position.lerpVectors(startPos, targetPos, 1 - Math.pow(1 - p, 3));
                camera.lookAt(0,0,0);
                if(p < 1) requestAnimationFrame(anim); else STATE.isFlying = false;
            }
            anim();
        }

        function resetGlobeState() {
            highlightMaterial.uniforms.uTargetId.value = -1.0;
            highlightMaterial.uniforms.uShowFlag.value = 0.0;
            highlightMaterial.uniforms.uFail.value = 0.0;
            STATE.found.clear();
            STATE.statusData.fill(0);
            STATE.statusTexture.needsUpdate = true;
            
            // Hide Label
            const label = document.getElementById('country-name-label');
            if(label) label.classList.remove('visible');

            document.querySelectorAll('.country-item').forEach(el => el.classList.remove('found-correct', 'found-skipped', 'selected'));
            // Clear selected countries set if present
            if (STATE.selectedCountries) STATE.selectedCountries.clear();

            // Remove any persistent 2D tags and sprites
            clearAllTags();
            // Remove flag sprites from globe
            if (STATE.flagSprites) {
                Object.values(STATE.flagSprites).forEach(sprite => {
                    globeGroup.remove(sprite);
                });
                STATE.flagSprites = {};
            }
            
            // Also reset view
            resetView();
        }

        // --- STATE/UI ---
        function setMode(modeId, difficulty, timeLimit) {
            STATE.mode = parseInt(modeId);
            if(difficulty) STATE.difficulty = difficulty;
            if(timeLimit !== undefined) STATE.timeLimit = timeLimit; else STATE.timeLimit = 0;

            STATE.score = 0; STATE.falseGuesses = 0; STATE.found.clear();
            STATE.correctCount = 0; STATE.totalQuestions = 0;
            STATE.gameStartTime = Date.now();
            STATE.isPaused = false;
            STATE.statusData.fill(0); STATE.statusTexture.needsUpdate = true;

            // For navigation mode (0), clear the quiz pool
            // For quiz modes, the pool should already be set by launchCustomMission() or quickPreset()
            if (STATE.mode === 0) {
                STATE.quizPool = [];
                STATE.quizPoolIndex = 0;
            } else if (STATE.quizPool.length === 0) {
                // If no quiz pool was set (legacy quick mode buttons), build a default pool
                QuizConfig.regions = ['all'];
                QuizConfig.questionCount = 'all';
                STATE.quizPool = buildQuizPool();
            }
            highlightMaterial.uniforms.uShowFlag.value = 0.0;
            
            // Clear accumulated flags
            if (FLAG_RENDER.canvas) FLAG_RENDER.clear();

            // Remove any persistent 2D tags and sprites when mode changes
            clearAllTags();
            if (STATE.flagSprites) {
                Object.values(STATE.flagSprites).forEach(sprite => {
                    globeGroup.remove(sprite);
                });
                STATE.flagSprites = {};
            }
            
            document.querySelectorAll('.country-item').forEach(el => el.classList.remove('found-correct', 'found-skipped', 'selected'));
            if (STATE.selectedCountries) STATE.selectedCountries.clear();
            
            // Hide Label on mode change
            const label = document.getElementById('country-name-label');
            if(label) label.classList.remove('visible');
            
            // Hide pause button initially
            document.getElementById('pause-btn')?.classList.add('hidden');
            document.getElementById('pause-overlay')?.classList.add('hidden');
            
            updateHUD();
            
            if (STATE.mode === 0) {
                document.getElementById('active-mode-display').textContent = "NAVIGATION MODE";
                document.getElementById('game-panel').classList.add('opacity-0', 'translate-y-40');
                document.getElementById('skip-btn').classList.add('hidden');
                document.getElementById('timer-ui').classList.add('hidden');
                document.getElementById('quiz-btn-text').textContent = "SELECT MISSION";
                highlightMaterial.uniforms.uTargetId.value = -1.0; 
                // Show mode panel with message
                const mPanel = document.getElementById('mode-panel');
                if (mPanel) {
                    // Build the panel content for navigation mode. Use the global accent color and default logo.
                    const icon = '<svg class="quiz-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';
                    mPanel.innerHTML = `${icon}<span class="font-black uppercase tracking-wider">Navigation Mode</span>`;
                    mPanel.style.background = getComputedStyle(document.documentElement).getPropertyValue('--panel-bg');
                    mPanel.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color');
                    mPanel.classList.add('show');
                    setTimeout(() => mPanel.classList.remove('show'), 2500);
                }
            } else {
                document.getElementById('active-mode-display').textContent = MODES[STATE.mode].name;
                document.getElementById('game-panel').classList.remove('opacity-0', 'translate-y-40');
                document.getElementById('quiz-btn-text').textContent = "QUIZ MENU";
                if (STATE.globalTimeLimit > 0) {
                    document.getElementById('timer-ui').classList.remove('hidden');
                    document.getElementById('countdown-display').textContent = STATE.globalTimeLimit;
                } else {
                    document.getElementById('timer-ui').classList.add('hidden');
                }
                if(STATE.loggedIn) controls.autoRotate = false;
                nextRound();
                // Show mode panel with the current mode name
                const mPanel = document.getElementById('mode-panel');
                if (mPanel) {
                    // Build the panel content for the selected mode. Use the mode's icon and colour as background accent.
                    const modeInfo = MODES[STATE.mode];
                    // Use the mode's colour for the background and border
                    mPanel.style.background = modeInfo.color + '33';
                    mPanel.style.borderColor = modeInfo.color;
                    mPanel.innerHTML = `${modeInfo.icon}<span class="font-black uppercase tracking-wider">${modeInfo.name} Mode</span>`;
                    mPanel.classList.add('show');
                    // During quiz, keep panel visible; hide only when returning to navigation mode.
                    // No timeout here so panel persists.
                }
            }
        }

        function updateHUD() {
            document.getElementById('score-display').textContent = STATE.score;
            // Display infinity symbol when error tracking is disabled (maxLives === Infinity)
            const max = (STATE.maxLives === Infinity ? '‚àû' : STATE.maxLives);
            document.getElementById('lives-display').textContent = `${STATE.falseGuesses}/${max}`;
            
            // Update high score display
            const modeKey = `mode_${STATE.mode}`;
            const currentHigh = STATE.highScores[modeKey] || 0;
            const highScoreEl = document.getElementById('high-score');
            const highScoreVal = document.getElementById('high-score-val');
            
            if (STATE.mode !== 0 && currentHigh > 0) {
                highScoreEl.classList.remove('hidden');
                highScoreVal.textContent = currentHigh;
            } else {
                highScoreEl.classList.add('hidden');
            }
            
            // Save new high score
            if (STATE.score > currentHigh && STATE.mode !== 0) {
                STATE.highScores[modeKey] = STATE.score;
                try {
                    localStorage.setItem('geoQuizHighScores', JSON.stringify(STATE.highScores));
                } catch(e) {}
            }
            
            // Marathon progress
            const marathonProgress = document.getElementById('marathon-progress');
            const marathonCount = document.getElementById('marathon-count');
            if (STATE.mode === 6) {
                marathonProgress.classList.remove('hidden');
                marathonProgress.classList.add('flex');
                marathonCount.textContent = `${STATE.found.size}/${STATE.countries.length}`;
            } else {
                marathonProgress.classList.add('hidden');
                marathonProgress.classList.remove('flex');
            }
        }

        // FIX 3: Global Control Toggles
        window.toggleGlobalDifficulty = () => {
            const btn = document.getElementById('global-diff-btn');
            const current = STATE.globalDifficulty;
            let next = 'medium';
            if(current === 'medium') next = 'hard';
            else if(current === 'hard') next = 'easy';
            
            STATE.globalDifficulty = next;
            
            btn.className = `hud-control-btn diff-${next}-active`;
            btn.title = `Difficulty: ${next.charAt(0).toUpperCase() + next.slice(1)}`;
            
            // If quiz is active, re-render to apply new difficulty rules (like showing/hiding MCQ)
            if(STATE.mode !== 0) {
                // Find current target and re-setup
                const target = STATE.countries.find(c => c.id === STATE.targetIndex);
                if(target) setupUI(target);
            }
        };

        window.toggleGlobalTimer = () => {
            const btn = document.getElementById('global-timer-btn');
            const badge = document.getElementById('timer-badge');
            let t = STATE.globalTimeLimit;
            if(t === 0) t = 3; else if(t === 3) t = 5; else if(t === 5) t = 10; else t = 0;
            
            STATE.globalTimeLimit = t;
            badge.textContent = t;
            
            if(t > 0) {
                btn.classList.add('timer-active');
                badge.classList.remove('hidden');
                if(STATE.mode !== 0) document.getElementById('timer-ui').classList.remove('hidden');
            } else {
                btn.classList.remove('timer-active');
                badge.classList.add('hidden');
                document.getElementById('timer-ui').classList.add('hidden');
            }
            
            // Restart timer for current round if active
            if(STATE.mode !== 0) nextRound(); // This is abrupt but ensures timer sync. Better: just reset timer logic
        };

        // Toggle whether mistakes count against the player's lives. When disabled,
        // the lives counter displays infinity and wrong guesses no longer reduce lives.
        window.toggleErrorTracking = () => {
            STATE.trackErrors = !STATE.trackErrors;
            if (STATE.trackErrors) {
                // Restore finite lives from base value
                STATE.maxLives = STATE.baseMaxLives;
            } else {
                // Disable lives by setting to Infinity
                STATE.maxLives = Infinity;
            }
            updateHUD();
            const btn = document.getElementById('error-toggle-btn');
            if (btn) {
                // Update text and colours inside the button itself
                btn.textContent = STATE.trackErrors ? 'ON' : 'OFF';
                btn.classList.toggle('error-on', STATE.trackErrors);
                btn.classList.toggle('error-off', !STATE.trackErrors);
            }
            // Grey out or restore the lives display when error tracking is off/on
            const livesEl = document.getElementById('lives-display');
            if (livesEl) {
                if (STATE.trackErrors) {
                    livesEl.style.opacity = '';
                    livesEl.style.filter = '';
                } else {
                    livesEl.style.opacity = '0.5';
                    livesEl.style.filter = 'grayscale(1)';
                }
            }
        };

        /* ============================================
           7. UI CONTROLLERS
           ============================================ */
        function populateSidebar() {
            const list = document.getElementById('country-list'); list.innerHTML = '';
            const grouped = {};
            STATE.countries.forEach(c => {
                let region = "Others";
                const sub = (c.subregion + c.continent).toLowerCase();
                if(sub.includes("africa")) region="Africa"; else if(sub.includes("europe")) region="Europe"; else if(sub.includes("asia")) region="Asia"; else if(sub.includes("north") || sub.includes("caribbean") || sub.includes("central")) region="North America"; else if(sub.includes("south")) region="South America"; else if(sub.includes("oceania") || sub.includes("australia")) region="Oceania";
                if(!grouped[region]) grouped[region] = []; grouped[region].push(c);
            });
            ["Africa", "Asia", "Europe", "North America", "South America", "Oceania", "Others"].forEach(r => {
                if(!grouped[r]) return;
                const h = document.createElement('div'); h.className = 'subregion-header'; h.textContent = r; list.appendChild(h);
                const grid = document.createElement('div'); grid.className = 'country-grid'; list.appendChild(grid);
                grouped[r].forEach(c => {
                    const d = document.createElement('div');
                    d.id = `country-${c.id}`;
                    d.className = 'country-item';
                    d.innerHTML = `<img src="https://flagcdn.com/w40/${c.iso.toLowerCase()}.png"><span>${c.name}</span>`;
                    d.onclick = () => {
                        if (STATE.mode === 0) {
                            // Fly to this country and update highlight
                            flyTo(c.center[0], c.center[1], false);
                            highlightMaterial.uniforms.uTargetId.value = c.id;
                            showFlagOnGlobe(c);
                            // Play selection sound
                            playSound('select');
                            // Persist the flag texture on the globe atlas
                            FLAG_RENDER.addFlag(c);
                            // Mark this country as found so the flag persists in the shader
                            if (c.id >= 0 && c.id < STATE.statusData.length) {
                                STATE.statusData[c.id] = 255;
                                STATE.statusTexture.needsUpdate = true;
                                STATE.found.add(c.id);
                            }
                            // Mark this country as selected in the index; do not deselect previous
                            d.classList.add('selected');
                            if (!STATE.selectedCountries) STATE.selectedCountries = new Set();
                            STATE.selectedCountries.add(c.id);
                        }
                    };
                    grid.appendChild(d);
                });
            });
        }

        function populateQuizMenu() {
            const container = document.getElementById('radial-menu');
            const centerBtn = container.querySelector('.radial-center-btn');
            container.innerHTML = ''; container.appendChild(centerBtn);

            const keys = Object.keys(MODES);
            const radius = 220; 
            const angleStep = (2 * Math.PI) / keys.length;

            keys.forEach((key, index) => {
                const m = MODES[key];
                const angle = index * angleStep - Math.PI / 2; 
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);

                const item = document.createElement('div');
                item.className = 'radial-item';
                item.style.setProperty('--item-color', m.color);
                item.style.left = `calc(50% + ${x}px - 70px)`; 
                item.style.top = `calc(50% + ${y}px - 70px)`;
                item.onclick = () => { closeQuizMenu(); setMode(key); };
                item.innerHTML = `
                    <div style="pointer-events: none;">
                        <div style="display:flex; justify-content:center;">${m.icon}</div>
                        <div class="font-black uppercase text-sm leading-tight mt-1">${m.name}</div>
                    </div>
                    <div class="quiz-drawer"><div>${m.desc}</div></div>
                `;
                container.appendChild(item);
            });
        }

        // --- QUIZ BUILDER HANDLERS ---
        function openQuizBuilder() {
            const modal = document.getElementById('quiz-builder');
            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.add('opacity-100'), 10);
            modal.classList.remove('opacity-0');
        }

        function closeQuizBuilder() {
            const modal = document.getElementById('quiz-builder');
            modal.classList.add('opacity-0');
            setTimeout(() => modal.classList.add('hidden'), 300);
        }

        function selectGiven(type, el) {
            QuizConfig.given = type;
            document.querySelectorAll('.given-btn').forEach(btn => btn.classList.remove('selected'));
            el.classList.add('selected');
            // Auto-adjust find if conflict (can't give and find same thing)
            if (QuizConfig.find === type) {
                const fallback = type === 'location' ? 'name' : 'location';
                selectFind(fallback, document.querySelector(`.find-btn[data-find="${fallback}"]`));
            }
            playSound('select');
        }

        function selectFind(type, el) {
            QuizConfig.find = type;
            document.querySelectorAll('.find-btn').forEach(btn => btn.classList.remove('selected'));
            el.classList.add('selected');
            // Auto-adjust given if conflict
            if (QuizConfig.given === type) {
                const fallback = type === 'location' ? 'name' : 'location';
                selectGiven(fallback, document.querySelector(`.given-btn[data-given="${fallback}"]`));
            }
            playSound('select');
        }

        function selectDifficulty(diff, el) {
            QuizConfig.difficulty = diff;
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('selected'));
            el.classList.add('selected');
            playSound('select');
        }

        function toggleRegion(region, el) {
            if (region === 'all') {
                // Select only 'all', deselect others
                QuizConfig.regions = ['all'];
                document.querySelectorAll('.region-chip').forEach(btn => btn.classList.remove('selected'));
                el.classList.add('selected');
            } else {
                // Remove 'all' if another region is selected
                const allChip = document.querySelector('.region-chip[data-region="all"]');
                allChip?.classList.remove('selected');
                QuizConfig.regions = QuizConfig.regions.filter(r => r !== 'all');

                // Toggle specific region
                if (QuizConfig.regions.includes(region)) {
                    QuizConfig.regions = QuizConfig.regions.filter(r => r !== region);
                    el.classList.remove('selected');
                } else {
                    QuizConfig.regions.push(region);
                    el.classList.add('selected');
                }

                // If no regions selected, re-select 'all'
                if (QuizConfig.regions.length === 0) {
                    QuizConfig.regions = ['all'];
                    allChip?.classList.add('selected');
                }
            }
            playSound('select');
        }

        function selectQuestionCount(count, el) {
            QuizConfig.questionCount = count;
            document.querySelectorAll('.param-btn[data-count]').forEach(btn => btn.classList.remove('selected'));
            el.classList.add('selected');
            playSound('select');
        }

        function selectTimeLimit(time, el) {
            QuizConfig.timeLimit = time;
            document.querySelectorAll('.param-btn[data-time]').forEach(btn => btn.classList.remove('selected'));
            el.classList.add('selected');
            playSound('select');
        }

        function selectLives(lives, el) {
            QuizConfig.lives = lives;
            document.querySelectorAll('.param-btn[data-lives]').forEach(btn => btn.classList.remove('selected'));
            el.classList.add('selected');
            playSound('select');
        }

        // Helper: Get region name from country object
        function getCountryRegion(country) {
            // Safely handle missing properties
            const subregion = (country.subregion || '').toLowerCase();
            const continent = (country.continent || '').toLowerCase();
            const combined = subregion + ' ' + continent;

            if (combined.includes("africa")) return "africa";
            if (combined.includes("europe")) return "europe";
            if (combined.includes("asia")) return "asia";
            if (combined.includes("north") || combined.includes("caribbean") || combined.includes("central america")) return "northamerica";
            if (combined.includes("south america")) return "southamerica";
            if (combined.includes("oceania") || combined.includes("australia")) return "oceania";
            return "other";
        }

        // Build quiz pool based on QuizConfig settings
        function buildQuizPool() {
            console.log('=== Building Quiz Pool ===');
            console.log('QuizConfig:', JSON.stringify(QuizConfig, null, 2));

            let pool = [...STATE.countries];
            console.log(`Initial pool: ${pool.length} countries`);

            // Filter by regions if not 'all'
            if (!QuizConfig.regions.includes('all')) {
                const beforeCount = pool.length;
                pool = pool.filter(country => {
                    const countryRegion = getCountryRegion(country);
                    const match = QuizConfig.regions.some(selectedRegion =>
                        countryRegion === selectedRegion.toLowerCase()
                    );
                    return match;
                });
                console.log(`After region filter: ${pool.length} countries (was ${beforeCount})`);
                console.log(`Regions selected: ${QuizConfig.regions.join(', ')}`);
                if (pool.length > 0) {
                    console.log(`Sample countries in pool: ${pool.slice(0, 5).map(c => `${c.name} (${getCountryRegion(c)})`).join(', ')}`);
                }
            }

            // NOTE: Removed broken rank-based difficulty filter
            // Countries don't have a 'rank' property, so we skip difficulty filtering
            // for now. All difficulty levels include all countries from selected regions.
            // TODO: Add area-based filtering for difficulty if needed
            console.log(`After difficulty filter: ${pool.length} countries (difficulty: ${QuizConfig.difficulty})`);

            // Shuffle the pool
            pool = shuffleArray(pool);

            // Limit to question count (unless 'all')
            if (QuizConfig.questionCount !== 'all') {
                const targetCount = typeof QuizConfig.questionCount === 'number'
                    ? QuizConfig.questionCount
                    : parseInt(QuizConfig.questionCount);
                if (!isNaN(targetCount) && targetCount < pool.length) {
                    pool = pool.slice(0, targetCount);
                    console.log(`After count limit: ${pool.length} countries (limit: ${targetCount})`);
                }
            }

            console.log(`Final quiz pool: ${pool.length} countries`);
            console.log('=========================');
            return pool;
        }

        // Fisher-Yates shuffle
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function launchCustomMission() {
            console.log('=== Launching Custom Mission ===');

            // Apply QuizConfig to game state
            STATE.globalDifficulty = QuizConfig.difficulty;
            STATE.globalTimeLimit = QuizConfig.timeLimit;
            STATE.maxLives = QuizConfig.lives;
            STATE.baseMaxLives = QuizConfig.lives === Infinity ? 999 : QuizConfig.lives;

            // Determine mode based on given/find combination
            // MODES: 1=Locate, 2=Identify, 3=Flag Match, 4=Rev. Locate, 5=Master, 6=Marathon
            let modeId = 1; // default: Locate (name -> location)
            const combo = `${QuizConfig.given}-${QuizConfig.find}`;
            console.log(`Quiz combo: ${combo}`);

            switch (combo) {
                case 'name-location':
                    modeId = 1; // Locate
                    break;
                case 'name-flag':
                    modeId = 3; // Flag Match
                    break;
                case 'flag-location':
                    modeId = 4; // Reverse Locate
                    break;
                case 'flag-name':
                    modeId = 2; // Identify
                    break;
                case 'location-name':
                    modeId = QuizConfig.difficulty === 'expert' ? 5 : 2; // Master (type) or Identify (MCQ)
                    break;
                case 'location-flag':
                    modeId = 3; // Flag Match
                    break;
            }

            // Marathon mode overrides if all questions selected
            if (QuizConfig.questionCount === 'all') {
                modeId = 6; // Marathon
            }

            console.log(`Selected mode: ${modeId}`);

            // Store custom config for later use
            STATE.customQuizConfig = { ...QuizConfig };

            // BUILD FILTERED QUIZ POOL - This is the key fix!
            STATE.quizPool = buildQuizPool();
            STATE.quizPoolIndex = 0;

            // Check if pool is empty
            if (STATE.quizPool.length === 0) {
                console.error('ERROR: Quiz pool is empty! No countries match the selected criteria.');
                alert('No countries match your selection. Please adjust your region or difficulty filters.');
                return;
            }

            console.log(`Quiz pool ready with ${STATE.quizPool.length} countries`);
            console.log('================================');

            closeQuizBuilder();
            setMode(modeId, QuizConfig.difficulty, QuizConfig.timeLimit);
        }

        function quickPreset(preset) {
            // Reset to defaults first
            QuizConfig.given = 'name';
            QuizConfig.find = 'location';
            QuizConfig.difficulty = 'medium';
            QuizConfig.regions = ['all'];
            QuizConfig.questionCount = 25;
            QuizConfig.timeLimit = 0;
            QuizConfig.lives = 3;

            switch (preset) {
                case 'locate':
                    QuizConfig.given = 'name';
                    QuizConfig.find = 'location';
                    break;
                case 'flaghunt':
                    QuizConfig.given = 'name';
                    QuizConfig.find = 'flag';
                    break;
                case 'identify':
                    QuizConfig.given = 'location';
                    QuizConfig.find = 'name';
                    break;
                case 'master':
                    QuizConfig.difficulty = 'hard';
                    QuizConfig.timeLimit = 10;
                    QuizConfig.lives = 1;
                    break;
                case 'marathon':
                    QuizConfig.questionCount = 'all';
                    QuizConfig.difficulty = 'hard';
                    QuizConfig.lives = Infinity;
                    break;
            }

            launchCustomMission();
        }

        // --- LISTENERS ---
        
        // Fuzzy matching for country names
        function normalizeString(str) {
            return str.toLowerCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // Remove accents
                .replace(/[^a-z0-9]/g, ''); // Remove non-alphanumeric
        }
        
        function fuzzyMatch(input, target) {
            const inputNorm = normalizeString(input);
            const targetNorm = normalizeString(target);
            if (inputNorm === targetNorm) return true;
            if (targetNorm.includes(inputNorm) && inputNorm.length >= 3) return true;
            // Common alternate names
            const aliases = {
                'usa': ['unitedstates', 'unitedstatesofamerica', 'america'],
                'uk': ['unitedkingdom', 'greatbritain', 'britain', 'england'],
                'uae': ['unitedarabemirates'],
                'drc': ['democraticrepublicofthecongo', 'democraticrepubliccongo'],
                'car': ['centralafricanrepublic'],
                'czechia': ['czechrepublic'],
                'ivorycoast': ['cotedivoire'],
            };
            for (const [short, longs] of Object.entries(aliases)) {
                if (inputNorm === short && longs.includes(targetNorm)) return true;
                if (longs.includes(inputNorm) && targetNorm.includes(short)) return true;
            }
            return false;
        }
        
        // Feedback class constant to reduce repetition
        const FEEDBACK_BASE_CLASS = "h-8 text-xl font-bold text-center tracking-widest uppercase transition-all duration-300 text-shadow-strong";

        // Helper to show feedback with animation
        function showFeedback(type, message, duration, callback) {
            const el = document.getElementById('feedback');
            if (!el) return;
            el.textContent = message;
            el.className = FEEDBACK_BASE_CLASS + (type ? ` feedback-${type}` : '');
            if (duration > 0) {
                setTimeout(() => {
                    el.className = FEEDBACK_BASE_CLASS;
                    if (callback) callback();
                }, duration);
            }
        }

        function checkTextAnswer(inputVal) {
            const target = STATE.countries.find(c => c.id === STATE.targetIndex);
            if (!target) return;

            if (fuzzyMatch(inputVal, target.name)) {
                success(target.id);
                showFeedback('success', 'CORRECT!', 1500, nextRound);
            } else {
                failEffect();
                showFeedback('fail', '', 500);
            }
            document.getElementById('answer-input').value = '';
        }
        
        // Form submission
        document.getElementById('type-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const inputVal = document.getElementById('answer-input').value.trim();
            if (!inputVal) return;
            checkTextAnswer(inputVal);
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!STATE.loggedIn || STATE.mode === 0) return;
            if (e.key === 'Escape' && !document.getElementById('skip-btn').classList.contains('hidden')) {
                document.getElementById('skip-btn').click();
            }
        });

        document.getElementById('login-btn').onclick = () => {
            const nameInput = document.getElementById('user-name');
            if(!nameInput.value.trim()){ alert("Enter Name"); return; }
            STATE.userName = nameInput.value; startGame();
        };
        document.getElementById('guest-btn').onclick = () => { STATE.userName = "Guest"; startGame(); };
        
        function startGame() {
            STATE.loggedIn = true;
            document.getElementById('login-modal').classList.add('opacity-0', 'pointer-events-none');
            document.getElementById('top-ui').classList.remove('opacity-0');
            document.getElementById('left-panel').classList.remove('pointer-events-none');
            document.getElementById('right-panel').classList.remove('pointer-events-none');
            // Initialize confetti system
            Confetti.init();
            setMode(0);
        }

        document.getElementById('toggle-left').onclick = () => document.getElementById('left-panel').classList.toggle('open');
        document.getElementById('toggle-right').onclick = () => document.getElementById('right-panel').classList.toggle('open');

        document.querySelectorAll('.settings-tab-btn').forEach(btn => {
            btn.onclick = (e) => {
                document.querySelectorAll('.settings-tab-btn').forEach(b => b.classList.remove('active-tab', 'opacity-100'));
                e.target.classList.add('active-tab', 'opacity-100');
                ['nav', 'style'].forEach(t => document.getElementById(`tab-${t}`).classList.add('hidden'));
                document.getElementById(`tab-${e.target.dataset.tab}`).classList.remove('hidden');
            };
        });

        function updateSlider(id, val) { const el = document.getElementById(id); if(el) { el.value = val; controls[id.replace('nav-', '').replace('speed', 'rotateSpeed').replace('min', 'minDistance').replace('max', 'maxDistance').replace('autorotate', 'autoRotateSpeed').replace('damping', 'dampingFactor')] = val; } }
        
        document.querySelectorAll('.nav-preset').forEach(btn => {
            btn.onclick = (e) => {
                document.querySelectorAll('.nav-preset').forEach(b => b.classList.remove('active')); e.target.classList.add('active');
                const val = e.target.dataset.val;
                if(val === 'low') { updateSlider('nav-speed', 0.2); updateSlider('nav-damping', 0.1); updateSlider('nav-zoom', 0.5); }
                if(val === 'med') { updateSlider('nav-speed', 0.5); updateSlider('nav-damping', 0.05); updateSlider('nav-zoom', 1.0); }
                if(val === 'high') { updateSlider('nav-speed', 1.0); updateSlider('nav-damping', 0.03); updateSlider('nav-zoom', 1.5); }
            };
        });

        const sliderMap = { 'nav-speed': 'rotateSpeed', 'nav-zoom': 'zoomSpeed', 'nav-damping': 'dampingFactor', 'nav-autorotate': 'autoRotateSpeed', 'nav-min': 'minDistance', 'nav-max': 'maxDistance' };
        Object.keys(sliderMap).forEach(id => document.getElementById(id).oninput = (e) => controls[sliderMap[id]] = parseFloat(e.target.value));

        function toggleSwitch(el, type) {
            el.classList.toggle('active'); const isActive = el.classList.contains('active');
            if(type === 'graticule') graticuleGroup.visible = isActive;
            if(type === 'borders') {
                if (STATE.borderGroup) STATE.borderGroup.visible = isActive;
            }
            if(type === 'crosshairCoords') {
                // Toggle whether lat/long coordinates are shown near the crosshair
                window.showCoordsFlag = isActive;
            }
            // Toggle whether the entire crosshair overlay is enabled.  When
            // disabled, the crosshair and coordinate label never appear.
            if(type === 'crosshairEnable') {
                window.crosshairEnabled = isActive;
                // Immediately hide crosshair when disabling
                const crosshair = document.getElementById('crosshair');
                if (crosshair && !isActive) {
                    crosshair.style.opacity = '0';
                }
            }
            // Toggle atmosphere visibility
            if(type === 'atmosphere') {
                if (STATE.atmoMesh) STATE.atmoMesh.visible = isActive;
            }
            // Toggle sunlight (directional light) visibility and apply city lights
            if(type === 'sunLight') {
                if (sunLight) {
                    sunLight.visible = isActive;
                }
                if (STATE.earthMaterial) {
                    if (isActive) {
                        // Enable night city lights on the dark side.  Load the
                        // emissive map if not already loaded.
                        if (!STATE.nightTexture) {
                            const loader = new THREE.TextureLoader();
                            loader.load('https://threejsfundamentals.org/threejs/resources/images/planets/earth_lights_2048.png', tex => {
                                tex.encoding = THREE.sRGBEncoding;
                                STATE.nightTexture = tex;
                                STATE.earthMaterial.emissiveMap = tex;
                                STATE.earthMaterial.emissive = new THREE.Color(0xffffff);
                                STATE.earthMaterial.emissiveIntensity = 1.0;
                                STATE.earthMaterial.needsUpdate = true;
                            });
                        } else {
                            STATE.earthMaterial.emissiveMap = STATE.nightTexture;
                            STATE.earthMaterial.emissive = new THREE.Color(0xffffff);
                            STATE.earthMaterial.emissiveIntensity = 1.0;
                            STATE.earthMaterial.needsUpdate = true;
                        }
                    } else {
                        // Disable emissive map when sunlight is turned off
                        STATE.earthMaterial.emissiveMap = null;
                        STATE.earthMaterial.emissiveIntensity = 0.0;
                        STATE.earthMaterial.needsUpdate = true;
                    }
                }
            }
            // Toggle decorative rings (equator & prime meridian)
            if(type === 'rings') {
                if (STATE.decorativeRings) STATE.decorativeRings.visible = isActive;
            }

            // Toggle environment map. When enabled, apply an HDR/environment texture to the scene background and globe material.
            if(type === 'environment') {
                if (isActive) {
                    // Load environment texture on demand if not already loaded. Use a simple starfield as the environment.
                    if (!STATE.envTexture) {
                        const loader = new THREE.TextureLoader();
                        loader.load('https://threejsfundamentals.org/threejs/resources/images/starfield.jpg', tex => {
                            // Use equirectangular mapping for environment and background
                            tex.mapping = THREE.EquirectangularReflectionMapping;
                            tex.encoding = THREE.sRGBEncoding;
                            STATE.envTexture = tex;
                            scene.background = tex;
                            scene.environment = tex;
                            // Apply environment as reflection map to earth material for subtle reflections
                            if (STATE.earthMaterial) {
                                STATE.earthMaterial.envMap = tex;
                                STATE.earthMaterial.needsUpdate = true;
                            }
                        });
                    } else {
                        scene.background = STATE.envTexture;
                        scene.environment = STATE.envTexture;
                        if (STATE.earthMaterial) {
                            STATE.earthMaterial.envMap = STATE.envTexture;
                            STATE.earthMaterial.needsUpdate = true;
                        }
                    }
                } else {
                    // Disable environment: remove background, environment and envMap from earth material
                    scene.background = null;
                    scene.environment = null;
                    if (STATE.earthMaterial) {
                        STATE.earthMaterial.envMap = null;
                        STATE.earthMaterial.needsUpdate = true;
                    }
                }
            }

            // Toggle raytracing: this is a placeholder that currently does nothing but could enable a path-traced renderer in future.
            if(type === 'raytracing') {
                if (isActive) {
                    console.log('Raytracing enabled (placeholder)');
                } else {
                    console.log('Raytracing disabled');
                }
            }
        }

        document.getElementById('border-color-picker').oninput = (e) => {
             if(STATE.borderMaterial) STATE.borderMaterial.color.set(e.target.value);
        };
        document.getElementById('border-thickness').oninput = (e) => {
             const v = parseFloat(e.target.value);
             if(STATE.borderMaterial) STATE.borderMaterial.opacity = v / 10;
        };
        document.getElementById('ui-border-width').oninput = (e) => document.documentElement.style.setProperty('--panel-border-width', e.target.value + 'px');

        // Crosshair color picker: update the CSS variable so lines and center shape adopt the new colour
        const crosshairColorPicker = document.getElementById('crosshair-color-picker');
        if (crosshairColorPicker) {
            crosshairColorPicker.oninput = (e) => {
                const val = e.target.value;
                document.documentElement.style.setProperty('--crosshair-color', val);
            };
        }

        // Crosshair font size slider: update CSS variable controlling coords label font size
        const crosshairFontSlider = document.getElementById('crosshair-font-slider');
        if (crosshairFontSlider) {
            crosshairFontSlider.oninput = (e) => {
                const val = e.target.value + 'px';
                document.documentElement.style.setProperty('--crosshair-font-size', val);
            };
        }

        // Crosshair enable toggle is managed via toggleSwitch.  Initialise state
        // variables for crosshair enable and coordinate offset.  Default
        // crosshairEnabled is true so the crosshair appears when over the
        // globe.
        window.crosshairEnabled = true;
        window.coordsOffsetY = 0;
        window.coordsOffsetX = 0;

        // Coordinates offset slider: adjust vertical offset of lat/long
        const coordsOffsetSlider = document.getElementById('coords-offset-slider');
        if (coordsOffsetSlider) {
            coordsOffsetSlider.oninput = (e) => {
                window.coordsOffsetY = parseInt(e.target.value, 10) || 0;
            };
        }

        // Coordinates horizontal offset slider: adjust horizontal offset of lat/long
        const coordsOffsetXSlider = document.getElementById('coords-offset-x-slider');
        if (coordsOffsetXSlider) {
            coordsOffsetXSlider.oninput = (e) => {
                window.coordsOffsetX = parseInt(e.target.value, 10) || 0;
            };
        }

        // Crosshair shape selector: change the corner radius of the central crosshair shape
        const shapeSelect = document.getElementById('crosshair-shape-select');
        if (shapeSelect) {
            shapeSelect.onchange = (e) => {
                const center = document.getElementById('crosshair-center');
                if (!center) return;
                center.style.borderRadius = (e.target.value === 'circle') ? '50%' : '0%';
            };
        }
        // Border thickness slider: adjust line width for country borders
        const borderWidthSlider = document.getElementById('border-width-slider');
        if (borderWidthSlider) {
            borderWidthSlider.oninput = (e) => {
                const v = parseFloat(e.target.value);
                if (STATE.borderMaterial) {
                    // Note: lineWidth support varies across platforms. Works best on Windows with WebGL1.
                    STATE.borderMaterial.linewidth = v;
                    STATE.borderMaterial.needsUpdate = true;
                }
            };
        }

        function setFlagSize(size, btn) {
            document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active');
            const sizes = { 'S': '1rem', 'M': '1.5rem', 'L': '2.5rem', 'XL': '4rem' };
            const fonts = { 'S': '0.75rem', 'M': '0.9rem', 'L': '1rem', 'XL': '1.2rem' };
            document.documentElement.style.setProperty('--flag-size', sizes[size]);
            document.documentElement.style.setProperty('--sidebar-font-size', fonts[size]);
        }

        window.openQuizMenu = () => { 
            const menu = document.getElementById('quiz-menu');
            menu.classList.remove('hidden', 'opacity-0', 'pointer-events-none');
            document.getElementById('game-over-modal').classList.add('hidden');
            const items = menu.querySelectorAll('.radial-item');
            items.forEach((item, index) => { setTimeout(() => { item.style.transform = 'scale(1)'; item.style.opacity = '1'; }, index * 50); });
        };

        window.closeQuizMenu = () => { 
            const menu = document.getElementById('quiz-menu');
            const items = menu.querySelectorAll('.radial-item');
            items.forEach((item) => { item.style.transform = 'scale(0)'; item.style.opacity = '0'; });
            setTimeout(() => { menu.classList.add('opacity-0', 'pointer-events-none'); setTimeout(() => menu.classList.add('hidden'), 300); }, 300);
        };

        window.gameOver = () => { 
            document.getElementById('game-over-modal').classList.remove('hidden'); 
            document.getElementById('game-panel').classList.add('opacity-0', 'translate-y-40'); 
            document.getElementById('pause-btn')?.classList.add('hidden');
            if(STATE.timerInterval) clearInterval(STATE.timerInterval);
            // Record stats
            STATS.record(STATE.mode, STATE.score, STATE.correctCount, STATE.totalQuestions, Date.now() - STATE.gameStartTime);
        };
        window.restartGame = () => { document.getElementById('game-over-modal').classList.add('hidden'); document.getElementById('victory-modal').classList.add('hidden'); setMode(STATE.mode); };
        window.exitToNav = () => { 
            document.getElementById('game-over-modal').classList.add('hidden'); 
            document.getElementById('victory-modal').classList.add('hidden'); 
            document.getElementById('pause-overlay').classList.add('hidden');
            STATE.isPaused = false;
            setMode(0); 
        };
        
        // Stats panel functions
        window.toggleStatsPanel = () => {
            const panel = document.getElementById('stats-panel');
            panel.classList.toggle('translate-x-full');
            if (!panel.classList.contains('translate-x-full')) {
                updateStatsDisplay();
            }
        };
        
        function updateStatsDisplay() {
            const games = STATS.games;
            
            // High scores by mode
            const highScoresEl = document.getElementById('high-scores-list');
            const modeNames = {1: 'Locate', 2: 'Identify', 3: 'Flag Match', 4: 'Rev. Locate', 5: 'Master', 6: 'Marathon'};
            let highScoresHtml = '';
            for (let mode = 1; mode <= 6; mode++) {
                const hs = STATS.getHighScore(mode);
                if (hs > 0) {
                    highScoresHtml += `<div class="flex justify-between items-center bg-white/5 rounded-lg px-3 py-2">
                        <span class="text-sm">${modeNames[mode]}</span>
                        <span class="font-mono font-bold" style="color: var(--accent-color)">${hs}</span>
                    </div>`;
                }
            }
            highScoresEl.innerHTML = highScoresHtml || '<div class="text-white/40 text-sm">No games played yet</div>';
            
            // Recent games
            const recentEl = document.getElementById('recent-games-list');
            const recent = games.slice(0, 10);
            if (recent.length > 0) {
                recentEl.innerHTML = recent.map(g => {
                    const date = new Date(g.date).toLocaleDateString();
                    return `<div class="flex justify-between items-center bg-white/5 rounded-lg px-3 py-2 text-xs">
                        <div>
                            <span class="font-bold">${modeNames[g.mode] || 'Unknown'}</span>
                            <span class="opacity-50 ml-2">${date}</span>
                        </div>
                        <span class="font-mono font-bold">${g.score}</span>
                    </div>`;
                }).join('');
            }
            
            // Statistics
            document.getElementById('stat-total-games').textContent = games.length;
            document.getElementById('stat-total-score').textContent = games.reduce((sum, g) => sum + g.score, 0);
            const totalCorrect = games.reduce((sum, g) => sum + (g.correct || 0), 0);
            const totalQuestions = games.reduce((sum, g) => sum + (g.total || 0), 0);
            document.getElementById('stat-accuracy').textContent = totalQuestions > 0 ? Math.round((totalCorrect / totalQuestions) * 100) + '%' : '0%';
            document.getElementById('stat-best-streak').textContent = Math.max(...games.map(g => g.correct || 0), 0);
        }
        
        window.clearStats = () => {
            if (confirm('Clear all game statistics? This cannot be undone.')) {
                STATS.games = [];
                localStorage.removeItem('geoQuizStats');
                updateStatsDisplay();
            }
        };
        
        // Pause functions
        window.togglePause = () => {
            if (STATE.mode === 0 || STATE.globalTimeLimit === 0) return;
            
            STATE.isPaused = !STATE.isPaused;
            const overlay = document.getElementById('pause-overlay');
            const pauseBtn = document.getElementById('pause-btn');
            
            if (STATE.isPaused) {
                // Store remaining time
                const elapsed = (Date.now() - STATE.questionStartTime) / 1000;
                STATE.pauseTimeRemaining = Math.max(0, STATE.globalTimeLimit - elapsed);
                document.getElementById('pause-time-display').textContent = Math.ceil(STATE.pauseTimeRemaining);
                
                // Pause timer
                if (STATE.timerInterval) clearInterval(STATE.timerInterval);
                
                overlay.classList.remove('hidden');
                pauseBtn.innerHTML = '<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';
            } else {
                overlay.classList.add('hidden');
                pauseBtn.innerHTML = '<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';
                
                // Resume timer with remaining time
                STATE.questionStartTime = Date.now() - ((STATE.globalTimeLimit - STATE.pauseTimeRemaining) * 1000);
                startQuestionTimer();
            }
        };
        
        function startQuestionTimer() {
            if (STATE.timerInterval) clearInterval(STATE.timerInterval);
            if (STATE.globalTimeLimit === 0) return;
            
            STATE.timerInterval = setInterval(() => {
                if (STATE.isPaused) return;
                
                const elapsed = (Date.now() - STATE.questionStartTime) / 1000;
                const remaining = Math.ceil(STATE.globalTimeLimit - elapsed);
                const timerEl = document.getElementById('countdown-display');
                if (timerEl) timerEl.textContent = remaining > 0 ? remaining : "!";
                
                if (remaining <= 0) {
                    clearInterval(STATE.timerInterval);
                    failEffect();
                    showFeedback('fail', 'TIME OUT', 0);
                    if (STATE.falseGuesses < STATE.maxLives) setTimeout(nextRound, 1500);
                }
            }, 100);
        }

        // Optimized event handlers with debounce/throttle
        const debouncedResize = debounce(() => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, 100);
        window.addEventListener('resize', debouncedResize);

        // Throttled mousemove for ~60fps interaction
        const throttledMouseMove = throttle((e) => handleInteraction(e, false), 16);
        window.addEventListener('mousemove', throttledMouseMove);
        window.addEventListener('click', (e) => handleInteraction(e, true));

        document.getElementById('skip-btn').onclick = () => {
            if(STATE.mode === 0) return;
            showFeedback(null, 'SKIPPED', 0);
            STATE.statusData[STATE.targetIndex] = 128; STATE.statusTexture.needsUpdate = true; // Red
            const item = document.getElementById(`country-${STATE.targetIndex}`);
            if(item) { item.classList.add('found-skipped'); item.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
            const c = STATE.countries.find(x => x.id === STATE.targetIndex);
            flyTo(c.center[0], c.center[1], false);
            updateHUD();
            setTimeout(nextRound, 2000);
        };

        // Toggle the visibility of all flag sprites when clicking the flag button in the sidebar
        const toggleFlagsBtn = document.getElementById('toggle-flags-btn');
        if (toggleFlagsBtn) {
            toggleFlagsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                STATE.showFlags = !(STATE.showFlags !== false);
                if (STATE.flagSprites) {
                    Object.values(STATE.flagSprites).forEach(sprite => {
                        sprite.visible = STATE.showFlags;
                    });
                }
                // Provide subtle visual feedback by toggling active class on button
                toggleFlagsBtn.classList.toggle('active');
            });
        }

        // Sidebar resizing via drag handle
        (function() {
            const handle = document.getElementById('left-handle');
            const panel = document.getElementById('left-panel');
            let dragging = false;
            if (handle && panel) {
                handle.addEventListener('mousedown', (e) => {
                    dragging = true;
                    e.preventDefault();
                });
                window.addEventListener('mousemove', (e) => {
                    if (!dragging) return;
                    const minWidth = 220; // minimum sidebar width in pixels
                    const maxWidth = window.innerWidth * 0.4; // cap at 40% of viewport
                    let newWidth = e.clientX;
                    newWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);
                    panel.style.width = newWidth + 'px';
                });
                window.addEventListener('mouseup', () => {
                    dragging = false;
                });
            }
        })();

        /**
         * Create a 2D flag tag for the specified country. The tag displays the
         * country flag and name on the overlay and persists until cleared.
         * Tags are stored in STATE.tagElements keyed by country id.
         * @param {Object} country Country data object
         */
        function createFlagTag(country) {
            if (!STATE.tagElements) STATE.tagElements = {};
            if (STATE.tagElements[country.id]) return;
            const tag = document.createElement('div');
            tag.className = 'flag-tag';
            tag.id = `flag-tag-${country.id}`;
            // Flag image
            const img = document.createElement('img');
            img.src = `https://flagcdn.com/w40/${country.iso.toLowerCase()}.png`;
            img.alt = `${country.name} flag`;
            tag.appendChild(img);
            // Country name
            const span = document.createElement('span');
            span.textContent = country.name;
            tag.appendChild(span);
            document.getElementById('tag-container').appendChild(tag);
            STATE.tagElements[country.id] = tag;
        }

        /**
         * Remove all existing flag tags and clear the tag registry.
         */
        function clearAllTags() {
            if (!STATE.tagElements) return;
            Object.keys(STATE.tagElements).forEach(id => {
                const el = STATE.tagElements[id];
                if (el && el.parentNode) el.parentNode.removeChild(el);
            });
            STATE.tagElements = {};
        }

        /**
         * Update the position and scale of all flag tags each frame. Tags will
         * follow their associated country's center position on the globe. When
         * a country is on the far side of the globe relative to the camera
         * (i.e., behind the horizon), the tag collapses into a small round
         * icon and clamps to the screen edges. Simple vertical spacing is
         * applied to minimise overlap between neighbouring tags.
         */
        function updateTagPositions() {
            if (!STATE.tagElements) return;
            const rectW = window.innerWidth;
            const rectH = window.innerHeight;
            const tagInfos = [];
            // Precompute camera direction and position once
            for (const id in STATE.tagElements) {
                const tag = STATE.tagElements[id];
                // Find the corresponding country by id (string vs number conversion)
                const c = STATE.countries.find(x => x.id === parseInt(id));
                if (!c) continue;
                // Compute 3D world position of the country's centroid slightly above surface
                const lat = c.center[0];
                const lon = c.center[1];
                const phi = (90 - lat) * Math.PI / 180;
                const theta = (lon + 180) * Math.PI / 180;
                const r = 10.05;
                const pos = new THREE.Vector3(
                    -r * Math.sin(phi) * Math.cos(theta),
                    r * Math.cos(phi),
                    r * Math.sin(phi) * Math.sin(theta)
                );
                const ndc = pos.clone().project(camera);
                // Convert to screen coordinates
                let x = (ndc.x * 0.5 + 0.5) * rectW;
                let y = (-ndc.y * 0.5 + 0.5) * rectH;
                // Determine if the tag is on the back hemisphere by comparing the direction to the camera forward vector
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                const toTag = pos.clone().sub(camera.position).normalize();
                const behind = (toTag.dot(camDir) < 0);
                if (behind) {
                    // For tags on the back hemisphere, clamp to the edges so the indicator sits at the horizon
                    x = Math.max(12, Math.min(rectW - 12, x));
                    y = Math.max(12, Math.min(rectH - 12, y));
                }
                // Compute distance to camera to scale tag
                const dist = pos.distanceTo(camera.position);
                tagInfos.push({ tag, x, y, behind, dist });
            }
            // Sort by Y coordinate to apply vertical spacing to reduce overlap
            tagInfos.sort((a, b) => a.y - b.y);
            // Increase minimum spacing to reduce overlap between tags
            const spacing = 28; // minimum vertical spacing between tags in pixels
            for (let i = 1; i < tagInfos.length; i++) {
                const prev = tagInfos[i - 1];
                const current = tagInfos[i];
                if (Math.abs(current.y - prev.y) < spacing) {
                    const diff = spacing - Math.abs(current.y - prev.y);
                    current.y += diff;
                }
            }
            // Apply positions and scaling to tags
            const hudHeight = 110; // approximate height of HUD/scoreboard to avoid overlapping tags
            for (const info of tagInfos) {
                const { tag, x, y, behind, dist } = info;
                // Clamp tags below the HUD
                let posY = y;
                if (posY < hudHeight) posY = hudHeight + 10;
                // Clamp to window edges
                let posX = Math.max(12, Math.min(rectW - 12, x));
                posY = Math.max(12, Math.min(rectH - 12, posY));
                tag.style.left = `${posX}px`;
                tag.style.top = `${posY}px`;
                // Determine scale: shrink aggressively when far and limit maximum size
                let scale = 1.0 / (dist / 20);
                // Clamp scale to a narrow range for subtle appearance
                scale = Math.max(0.08, Math.min(0.25, scale));
                if (behind) {
                    // Tags on the far side should fade out completely
                    tag.classList.remove('far');
                    tag.style.opacity = '0';
                    tag.style.transform = 'translate(-50%, -50%) scale(0)';
                } else {
                    tag.style.opacity = '1';
                    // If within view, show as circle or normal tag based on far distance threshold
                    if (dist > 25) {
                        tag.classList.add('far');
                    } else {
                        tag.classList.remove('far');
                    }
                    tag.style.transform = `translate(-50%, -50%) scale(${scale})`;
                }
            }
        }

        // Crosshair update: move vertical and horizontal lines, central shape and coordinates to follow mouse
        (function() {
            const crosshair = document.getElementById('crosshair');
            const vLine = crosshair && crosshair.querySelector('.v-line');
            const hLine = crosshair && crosshair.querySelector('.h-line');
            const centerEl = document.getElementById('crosshair-center');
            const coordsEl = document.getElementById('crosshair-coords');
            // Raycaster for lat/long computation
            const raycaster2 = new THREE.Raycaster();
            // Default show coords
            window.showCoordsFlag = true;
            if (vLine && hLine && centerEl) {
                window.addEventListener('mousemove', (e) => {
                    // If the crosshair is globally disabled, always hide it and do nothing
                    if (!window.crosshairEnabled) {
                        if (crosshair) crosshair.style.opacity = '0';
                        if (coordsEl) coordsEl.style.display = 'none';
                        return;
                    }
                    // Determine if hovering over UI panels
                    const isUi = e.target.closest('#login-modal, #left-panel, #right-panel, #quiz-menu, #game-panel, #hud-bar, #splash-screen, .naked-btn, #country-name-label');
                    if (!isUi) {
                        // Determine if the mouse is hovering over the globe (intersecting the earth mesh)
                        const mouse = new THREE.Vector2((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
                        raycaster2.setFromCamera(mouse, camera);
                        const earthMesh = globeGroup.children.find(c => c.name === "Earth");
                        let intersectsEarth = false;
                        if (earthMesh) {
                            const intersects = raycaster2.intersectObject(earthMesh);
                            intersectsEarth = intersects.length > 0;
                        }
                        if (intersectsEarth) {
                            // Show crosshair when over globe
                            if (crosshair) crosshair.style.opacity = '1';
                            vLine.style.left = `${e.clientX}px`;
                            hLine.style.top = `${e.clientY}px`;
                            centerEl.style.left = `${e.clientX}px`;
                            centerEl.style.top = `${e.clientY}px`;
                        } else {
                            // Hide crosshair when not over globe
                            if (crosshair) crosshair.style.opacity = '0';
                            if (coordsEl) coordsEl.style.display = 'none';
                        }
                        // Update coordinates if enabled and over globe
                        if (coordsEl) {
                            if (window.showCoordsFlag && intersectsEarth) {
                                const intersects = raycaster2.intersectObject(earthMesh);
                                if (intersects && intersects.length > 0) {
                                    const p = intersects[0].point.clone().normalize();
                                    const lat = Math.asin(p.y) * 180 / Math.PI;
                                    const lon = Math.atan2(p.z, p.x) * 180 / Math.PI;
                                    const latDir = lat >= 0 ? 'N' : 'S';
                                    const lonDir = lon >= 0 ? 'E' : 'W';
                                    const latAbs = Math.abs(lat).toFixed(1);
                                    const lonAbs = Math.abs(lon).toFixed(1);
                                    coordsEl.textContent = `${latAbs}¬∞${latDir}, ${lonAbs}¬∞${lonDir}`;
                                    // Apply user-defined coordinate offset for fine positioning
                                    // Apply user-defined horizontal and vertical offsets to coordinate label
                                    coordsEl.style.left = `${e.clientX + (window.coordsOffsetX || 0)}px`;
                                    coordsEl.style.top = `${e.clientY + (window.coordsOffsetY || 0) - 14}px`;
                                    coordsEl.style.display = 'block';
                                } else {
                                    coordsEl.style.display = 'none';
                                }
                            } else {
                                coordsEl.style.display = 'none';
                            }
                        }
                    } else {
                        // Hide crosshair when interacting with UI panels
                        if (crosshair) crosshair.style.opacity = '0';
                        if (coordsEl) coordsEl.style.display = 'none';
                    }
                });
            }
        })();

        /* ============================================
           9. ANIMATION LOOP
           ============================================ */
        let lastAnimTime = 0;
        function animate(time) {
            // Skip if document is hidden (tab not active)
            if (document.hidden) return;

            // Time-based animation delta
            const delta = time - lastAnimTime;
            lastAnimTime = time;

            controls.update();

            // Update highlight shader time (time-based for consistent animation)
            if (highlightMaterial) highlightMaterial.uniforms.uTime.value = time * 0.001;

            // Update small flag sprites to face camera and scale with distance
            if (STATE.flagSprites) {
                const camPos = camera.position;
                for (const key in STATE.flagSprites) {
                    const sprite = STATE.flagSprites[key];
                    if (!sprite) continue;
                    // Make sprite face camera
                    sprite.lookAt(camPos);
                    // Dynamic scaling: shrink when far, enlarge when close
                    const dist = sprite.position.distanceTo(camPos);
                    // Base size controls overall appearance; adjust to taste
                    let size = 1.2 / (dist / 15);
                    // Constrain size range for subtler sprites
                    size = Math.min(1.0, Math.max(0.2, size));
                    const aspect = sprite.userData.flagAspect || 1;
                    sprite.scale.set(size, size / aspect, 1);
                }
            }
            // Update positions of all 2D flag tags
            updateTagPositions();
            renderer.render(scene, camera);
        }

        // Use setAnimationLoop for better frame timing
        function startAnimationLoop() {
            renderer.setAnimationLoop(animate);
        }

        /* ============================================
           10. INITIALIZATION
           ============================================ */
        console.log('Starting loadData and animation loop...');
        try {
            loadData();
            startAnimationLoop();
            // Automatically enter navigation mode as guest on load to streamline testing and avoid login prompt.
            if (!STATE.loggedIn && typeof startGame === 'function') {
                startGame();
            }
        } catch(e) {
            console.error('Startup error:', e);
        }
    </script>
</body>
</html>